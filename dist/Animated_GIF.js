(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Animated_GIF = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.

"use strict";

function GifWriter(buf, width, height, gopts) {
  var p = 0;

  var gopts = gopts === undefined ? { } : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;

  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
    throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;
    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
      throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256.");
    }
    return num_colors;
  }

  // - Header.
  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

  // Handling of Global Color Table (palette) and background index.
  var gp_num_colors_pow2 = 0;
  var background = 0;
  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);
    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;
    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors)
        throw new Error("Background index out of range.");
      // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).
      if (background === 0)
        throw new Error("Background index explicitly passed as 0.");
    }
  }

  // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
  // NOTE: Indicates 0-bpp original color resolution (unused?).
  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
  buf[p++] = background;  // Background Color Index.
  buf[p++] = 0;  // Pixel aspect ratio (unused?).

  // - Global Color Table
  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {  // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535)
      throw new Error("Loop count invalid.")
    // Extension code, label, and length.
    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
    // NETSCAPE2.0
    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
    // Sub-block
    buf[p++] = 0x03; buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00;  // Terminator.
  }


  var ended = false;

  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
    if (ended === true) { --p; ended = false; }  // Un-end.

    opts = opts === undefined ? { } : opts;

    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?
    if (x < 0 || y < 0 || x > 65535 || y > 65535)
      throw new Error("x/y invalid.")

    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
      throw new Error("Width/Height invalid.")

    if (indexed_pixels.length < w * h)
      throw new Error("Not enough pixels for the frame size.");

    var using_local_palette = true;
    var palette = opts.palette;
    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null)
      throw new Error("Must supply either a local or global palette.");

    var num_colors = check_palette_and_num_colors(palette);

    // Compute the min_code_size (power of 2), destroying num_colors.
    var min_code_size = 0;
    while (num_colors >>= 1) ++min_code_size;
    num_colors = 1 << min_code_size;  // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay;

    // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.
    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
      throw new Error("Disposal out of range.");

    var use_transparency = false;
    var transparent_index = 0;
    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors)
        throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
      buf[p++] = 4;  // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index;  // Transparent color index.
      buf[p++] = 0;  // Block Terminator.
    }

    // - Image Descriptor
    buf[p++] = 0x2c;  // Image Seperator.
    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
    // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.
    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

    // - Local Color Table
    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(
            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

    return p;
  };

  this.end = function() {
    if (ended === false) {
      buf[p++] = 0x3b;  // Trailer.
      ended = true;
    }
    return p;
  };

  this.getOutputBuffer = function() { return buf; };
  this.setOutputBuffer = function(v) { buf = v; };
  this.getOutputBufferPosition = function() { return p; };
  this.setOutputBufferPosition = function(v) { p = v; };
}

// Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.
function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++;  // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  var cur_shift = 0;
  // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).
  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8; cur_shift -= 8;
      if (p === cur_subblock + 256) {  // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  }

  // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.

  // Output code for the current contents of the index buffer.
  var ib_code = index_stream[0] & code_mask;  // Load first input index.
  var code_table = { };  // Key'd on our 20-bit "tuple".

  emit_code(clear_code);  // Spec says first code should be a clear code.

  // First index already loaded, process the rest of the stream.
  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
    var cur_code = code_table[cur_key];  // buffer + k.

    // Check if we have to create a new code table entry.
    if (cur_code === undefined) {  // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;
      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8; cur_shift -= 8;
        if (p === cur_subblock + 256) {  // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {  // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = { };
      } else {  // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
        code_table[cur_key] = next_code++;  // Insert into code table.
      }

      ib_code = k;  // Index buffer to single input k.
    } else {
      ib_code = cur_code;  // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code);  // There will still be something in the index buffer.
  emit_code(eoi_code);  // End Of Information.

  // Flush / finalize the sub-blocks stream to the buffer.
  emit_bytes_to_buffer(1);

  // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.
  if (cur_subblock + 1 === p) {  // Started but unused.
    buf[cur_subblock] = 0;
  } else {  // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }
  return p;
}

function GifReader(buf) {
  var p = 0;

  // - Header (GIF87a or GIF89a).
  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  }

  // - Logical Screen Descriptor.
  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++];  // <Packed Fields>.
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
  var background = buf[p++];
  buf[p++];  // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size   = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3;  // Seek past palette.
  }

  var no_eof = true;

  var frames = [ ];

  var delay = 0;
  var transparent_index = null;
  var disposal = 0;  // 0 - No disposal specified.
  var loop_count = null;

  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:  // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:  // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
                // Sub-block
                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++;  // Skip terminator.
            } else {  // We don't know what it is, just try to get past it.
              p += 12;
              while (true) {  // Seek through subblocks.
                var block_size = buf[p++];
                // Bad block size (ex: undefined from an out of bounds read).
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;  // 0 size is terminator
                p += block_size;
              }
            }
            break;

          case 0xf9:  // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++;  // Skip terminator.
            break;

          case 0xfe:  // Comment Extension.
            while (true) {  // Seek through subblocks.
              var block_size = buf[p++];
              // Bad block size (ex: undefined from an out of bounds read).
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;  // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));
              p += block_size;
            }
            break;

          default:
            throw new Error(
                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
        }
        break;

      case 0x2c:  // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p;  // Override with local palette.
          palette_size = num_local_colors;
          p += num_local_colors * 3;  // Seek past palette.
        }

        var data_offset = p;

        p++;  // codesize
        while (true) {
          var block_size = buf[p++];
          // Bad block size (ex: undefined from an out of bounds read).
          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break;  // 0 size is terminator
          p += block_size;
        }

        frames.push({x: x, y: y, width: w, height: h,
                     has_local_palette: has_local_palette,
                     palette_offset: palette_offset,
                     palette_size: palette_size,
                     data_offset: data_offset,
                     data_length: p - data_offset,
                     transparent_index: transparent_index,
                     interlaced: !!interlace_flag,
                     delay: delay,
                     disposal: disposal});
        break;

      case 0x3b:  // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
        break;
    }
  }

  this.numFrames = function() {
    return frames.length;
  };

  this.loopCount = function() {
    return loop_count;
  };

  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  }

  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };

  // I will go to copy and paste hell one day...
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];

  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;

  var op = 0;  // Output pointer.

  var subblock_size = code_stream[p++];

  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);
  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

  var prev_code = null;  // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break;  // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++];  // Next subblock.
      } else {
        --subblock_size;
      }
    }

    // TODO(deanm): We should never really get here, we should have received
    // and EOI.
    if (cur_shift < cur_code_size)
      break;

    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;

    // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.
    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.

      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;

      // Don't update prev_code ?
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }

    // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.

    var chase_code = code < next_code ? code : prev_code;

    // Chase what we will output, either {CODE} or {CODE-1}.
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;

    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    }

    // Already have the first byte from the chase, might as well write it fast.
    output[op++] = k;

    op += chase_length;
    var b = op;  // Track pointer, writing backwards.

    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
      output[op++] = k;

    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff;  // Write backwards.
      chase >>= 8;  // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).
      if (next_code >= code_mask+1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
}

// CommonJS.
try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}

},{}],2:[function(require,module,exports){
// A library/utility for generating GIF files
// Uses Dean McNamee's omggif library
// and Anthony Dekker's NeuQuant quantizer (JS 0.3 version with many fixes)
//
// @author sole / http://soledadpenades.com
function Animated_GIF(globalOptions) {
  'use strict'

  globalOptions = globalOptions || {}

  const GifWriter = require('omggif').GifWriter

  let globalWidth = globalOptions.width || 160
  let globalHeight = globalOptions.height || 120
  const globalDithering = globalOptions.dithering || null
  const globalPalette = globalOptions.palette || null
  const searchForTransparency = globalOptions.searchForTransparency || false
  const globalDisposal = globalOptions.disposal || 0
  const globalTransparencyCutOff = globalOptions.transparencyCutOff || 0.7 // used for normalizing pixels to be full transparent or opaque
  var canvas = null,
    ctx = null,
    repeat = 0,
    delay = 250
  var frames = []
  var numRenderedFrames = 0
  var onRenderCompleteCallback = function() {}
  var onRenderProgressCallback = function() {}
  var sampleInterval
  var workers = [],
    availableWorkers = [],
    numWorkers
  var generatingGIF = false

  // We'll try to be a little lenient with the palette so as to make the library easy to use
  // The only thing we can't cope with is having a non-array so we'll bail on that one.
  if (globalPalette) {
    if (!(globalPalette instanceof Array)) {
      throw ('Palette MUST be an array but it is: ', globalPalette)
    } else {
      // Now there are other two constraints that we will warn about
      // and silently fix them... somehow:

      // a) Must contain between 2 and 256 colours
      if (globalPalette.length < 2 || globalPalette.length > 256) {
        console.error('Palette must hold only between 2 and 256 colours')

        while (globalPalette.length < 2) {
          globalPalette.push(0x000000)
        }

        if (globalPalette.length > 256) {
          globalPalette = globalPalette.slice(0, 256)
        }
      }

      // b) Must be power of 2
      if (!powerOfTwo(globalPalette.length)) {
        console.error('Palette must have a power of two number of colours')

        while (!powerOfTwo(globalPalette.length)) {
          globalPalette.splice(globalPalette.length - 1, 1)
        }
      }
    }
  }

  globalOptions = globalOptions || {}
  sampleInterval = globalOptions.sampleInterval || 10
  numWorkers = globalOptions.numWorkers || 2

  for (var i = 0; i < numWorkers; i++) {
    var w = new Worker((window.URL || window.webkitURL).createObjectURL(new Blob(['(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module \'"+i+"\'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n(function (global){\n(function (global, factory) {\n\ttypeof exports === \'object\' && typeof module !== \'undefined\' ? factory(exports) :\n\ttypeof define === \'function\' && define.amd ? define([\'exports\'], factory) :\n\t(factory((global[\'image-q\'] = {})));\n}(this, (function (exports) { \'use strict\';\n\nvar commonjsGlobal = typeof window !== \'undefined\' ? window : typeof global !== \'undefined\' ? global : typeof self !== \'undefined\' ? self : {};\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \'default\') ? x[\'default\'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar bt709 = createCommonjsModule(function (module, exports) {\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * sRGB (based on ITU-R Recommendation BT.709)\r\n * http://en.wikipedia.org/wiki/SRGB\r\n */\r\nvar Y;\r\n(function (Y) {\r\n    Y[Y["RED"] = 0.2126] = "RED";\r\n    Y[Y["GREEN"] = 0.7152] = "GREEN";\r\n    Y[Y["BLUE"] = 0.0722] = "BLUE";\r\n    Y[Y["WHITE"] = 1] = "WHITE";\r\n})(Y = exports.Y || (exports.Y = {}));\r\n// tslint:disable-next-line:naming-convention\r\nvar x;\r\n(function (x) {\r\n    x[x["RED"] = 0.64] = "RED";\r\n    x[x["GREEN"] = 0.3] = "GREEN";\r\n    x[x["BLUE"] = 0.15] = "BLUE";\r\n    x[x["WHITE"] = 0.3127] = "WHITE";\r\n})(x = exports.x || (exports.x = {}));\r\n// tslint:disable-next-line:naming-convention\r\nvar y;\r\n(function (y) {\r\n    y[y["RED"] = 0.33] = "RED";\r\n    y[y["GREEN"] = 0.6] = "GREEN";\r\n    y[y["BLUE"] = 0.06] = "BLUE";\r\n    y[y["WHITE"] = 0.329] = "WHITE";\r\n})(y = exports.y || (exports.y = {}));\r\n\n});\n\nunwrapExports(bt709);\nvar bt709_1 = bt709.Y;\nvar bt709_2 = bt709.x;\nvar bt709_3 = bt709.y;\n\nvar constants = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\n\r\nexports.bt709 = bt709;\r\n\n});\n\nunwrapExports(constants);\nvar constants_1 = constants.bt709;\n\nvar rgb2xyz_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2xyz.ts - part of Image Quantization Library\r\n */\r\nfunction correctGamma(n) {\r\n    return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;\r\n}\r\nfunction rgb2xyz(r, g, b) {\r\n    // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\n    r = correctGamma(r / 255);\r\n    g = correctGamma(g / 255);\r\n    b = correctGamma(b / 255);\r\n    // Observer. = 2\xB0, Illuminant = D65\r\n    return {\r\n        x: r * 0.4124 + g * 0.3576 + b * 0.1805,\r\n        y: r * 0.2126 + g * 0.7152 + b * 0.0722,\r\n        z: r * 0.0193 + g * 0.1192 + b * 0.9505,\r\n    };\r\n}\r\nexports.rgb2xyz = rgb2xyz;\r\n\n});\n\nunwrapExports(rgb2xyz_1);\nvar rgb2xyz_2 = rgb2xyz_1.rgb2xyz;\n\nvar arithmetic = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\nfunction degrees2radians(n) {\r\n    return n * (Math.PI / 180);\r\n}\r\nexports.degrees2radians = degrees2radians;\r\nfunction max3(a, b, c) {\r\n    var m = a;\r\n    if (m < b)\r\n        m = b;\r\n    if (m < c)\r\n        m = c;\r\n    return m;\r\n}\r\nexports.max3 = max3;\r\nfunction min3(a, b, c) {\r\n    var m = a;\r\n    if (m > b)\r\n        m = b;\r\n    if (m > c)\r\n        m = c;\r\n    return m;\r\n}\r\nexports.min3 = min3;\r\nfunction intInRange(value, low, high) {\r\n    if (value > high)\r\n        value = high;\r\n    if (value < low)\r\n        value = low;\r\n    return value | 0;\r\n}\r\nexports.intInRange = intInRange;\r\nfunction inRange0to255Rounded(n) {\r\n    n = Math.round(n);\r\n    if (n > 255)\r\n        n = 255;\r\n    else if (n < 0)\r\n        n = 0;\r\n    return n;\r\n}\r\nexports.inRange0to255Rounded = inRange0to255Rounded;\r\nfunction inRange0to255(n) {\r\n    if (n > 255)\r\n        n = 255;\r\n    else if (n < 0)\r\n        n = 0;\r\n    return n;\r\n}\r\nexports.inRange0to255 = inRange0to255;\r\nfunction stableSort(arrayToSort, callback) {\r\n    var type = typeof arrayToSort[0];\r\n    var sorted;\r\n    if (type === \'number\' || type === \'string\') {\r\n        var ord_1 = Object.create(null); // tslint:disable-line:no-null-keyword\r\n        for (var i = 0, l = arrayToSort.length; i < l; i++) {\r\n            var val = arrayToSort[i]; // tslint:disable-line:no-any\r\n            if (ord_1[val] || ord_1[val] === 0)\r\n                continue;\r\n            ord_1[val] = i;\r\n        }\r\n        sorted = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord_1[a] - ord_1[b];\r\n        });\r\n    }\r\n    else {\r\n        var ord2_1 = arrayToSort.slice(0);\r\n        sorted = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord2_1.indexOf(a) - ord2_1.indexOf(b);\r\n        });\r\n    }\r\n    return sorted;\r\n}\r\nexports.stableSort = stableSort;\r\n\n});\n\nunwrapExports(arithmetic);\nvar arithmetic_1 = arithmetic.degrees2radians;\nvar arithmetic_2 = arithmetic.max3;\nvar arithmetic_3 = arithmetic.min3;\nvar arithmetic_4 = arithmetic.intInRange;\nvar arithmetic_5 = arithmetic.inRange0to255Rounded;\nvar arithmetic_6 = arithmetic.inRange0to255;\nvar arithmetic_7 = arithmetic.stableSort;\n\nvar rgb2hsl_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2hsl.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * Calculate HSL from RGB\r\n * Hue is in degrees [0..360]\r\n * Lightness: [0..1]\r\n * Saturation: [0..1]\r\n * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\r\n */\r\nfunction rgb2hsl(r, g, b) {\r\n    var min = arithmetic.min3(r, g, b);\r\n    var max = arithmetic.max3(r, g, b);\r\n    var delta = max - min;\r\n    var l = (min + max) / 510;\r\n    var s = 0;\r\n    if (l > 0 && l < 1)\r\n        s = delta / (l < 0.5 ? (max + min) : (510 - max - min));\r\n    var h = 0;\r\n    if (delta > 0) {\r\n        if (max === r) {\r\n            h = (g - b) / delta;\r\n        }\r\n        else if (max === g) {\r\n            h = (2 + (b - r) / delta);\r\n        }\r\n        else {\r\n            h = (4 + (r - g) / delta);\r\n        }\r\n        h *= 60;\r\n        if (h < 0)\r\n            h += 360;\r\n    }\r\n    return { h: h, s: s, l: l };\r\n}\r\nexports.rgb2hsl = rgb2hsl;\r\n\n});\n\nunwrapExports(rgb2hsl_1);\nvar rgb2hsl_2 = rgb2hsl_1.rgb2hsl;\n\nvar xyz2lab_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2lab.ts - part of Image Quantization Library\r\n */\r\nvar refX = 0.95047; // ref_X =  95.047   Observer= 2\xB0, Illuminant= D65\r\nvar refY = 1.00000; // ref_Y = 100.000\r\nvar refZ = 1.08883; // ref_Z = 108.883\r\nfunction pivot(n) {\r\n    return n > 0.008856 ? Math.pow(n, 1 / 3) : (7.787 * n + 16 / 116);\r\n}\r\nfunction xyz2lab(x, y, z) {\r\n    x = pivot(x / refX);\r\n    y = pivot(y / refY);\r\n    z = pivot(z / refZ);\r\n    if ((116 * y) - 16 < 0)\r\n        throw new Error(\'xxx\');\r\n    return {\r\n        L: Math.max(0, (116 * y) - 16),\r\n        a: 500 * (x - y),\r\n        b: 200 * (y - z),\r\n    };\r\n}\r\nexports.xyz2lab = xyz2lab;\r\n\n});\n\nunwrapExports(xyz2lab_1);\nvar xyz2lab_2 = xyz2lab_1.xyz2lab;\n\nvar rgb2lab_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2lab.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nfunction rgb2lab(r, g, b) {\r\n    var xyz = rgb2xyz_1.rgb2xyz(r, g, b);\r\n    return xyz2lab_1.xyz2lab(xyz.x, xyz.y, xyz.z);\r\n}\r\nexports.rgb2lab = rgb2lab;\r\n\n});\n\nunwrapExports(rgb2lab_1);\nvar rgb2lab_2 = rgb2lab_1.rgb2lab;\n\nvar lab2xyz_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2xyz.ts - part of Image Quantization Library\r\n */\r\nvar refX = 0.95047; // ref_X =  95.047   Observer= 2\xB0, Illuminant = D65\r\nvar refY = 1.00000; // ref_Y = 100.000\r\nvar refZ = 1.08883; // ref_Z = 108.883\r\nfunction pivot(n) {\r\n    return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;\r\n}\r\n// tslint:disable-next-line:naming-convention\r\nfunction lab2xyz(L, a, b) {\r\n    var y = (L + 16) / 116;\r\n    var x = a / 500 + y;\r\n    var z = y - b / 200;\r\n    return {\r\n        x: refX * pivot(x),\r\n        y: refY * pivot(y),\r\n        z: refZ * pivot(z),\r\n    };\r\n}\r\nexports.lab2xyz = lab2xyz;\r\n\n});\n\nunwrapExports(lab2xyz_1);\nvar lab2xyz_2 = lab2xyz_1.lab2xyz;\n\nvar xyz2rgb_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2rgb.ts - part of Image Quantization Library\r\n */\r\n\r\n// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\nfunction correctGamma(n) {\r\n    return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;\r\n}\r\nfunction xyz2rgb(x, y, z) {\r\n    // Observer. = 2\xB0, Illuminant = D65\r\n    var r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986);\r\n    var g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415);\r\n    var b = correctGamma(x * 0.0557 + y * -0.2040 + z * 1.0570);\r\n    return {\r\n        r: arithmetic.inRange0to255Rounded(r * 255),\r\n        g: arithmetic.inRange0to255Rounded(g * 255),\r\n        b: arithmetic.inRange0to255Rounded(b * 255),\r\n    };\r\n}\r\nexports.xyz2rgb = xyz2rgb;\r\n\n});\n\nunwrapExports(xyz2rgb_1);\nvar xyz2rgb_2 = xyz2rgb_1.xyz2rgb;\n\nvar lab2rgb_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2rgb.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n// tslint:disable-next-line:naming-convention\r\nfunction lab2rgb(L, a, b) {\r\n    var xyz = lab2xyz_1.lab2xyz(L, a, b);\r\n    return xyz2rgb_1.xyz2rgb(xyz.x, xyz.y, xyz.z);\r\n}\r\nexports.lab2rgb = lab2rgb;\r\n\n});\n\nunwrapExports(lab2rgb_1);\nvar lab2rgb_2 = lab2rgb_1.lab2rgb;\n\nvar conversion = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\nexports.rgb2xyz = rgb2xyz_1.rgb2xyz;\r\n\r\nexports.rgb2hsl = rgb2hsl_1.rgb2hsl;\r\n\r\nexports.rgb2lab = rgb2lab_1.rgb2lab;\r\n\r\nexports.lab2xyz = lab2xyz_1.lab2xyz;\r\n\r\nexports.lab2rgb = lab2rgb_1.lab2rgb;\r\n\r\nexports.xyz2lab = xyz2lab_1.xyz2lab;\r\n\r\nexports.xyz2rgb = xyz2rgb_1.xyz2rgb;\r\n\n});\n\nunwrapExports(conversion);\nvar conversion_1 = conversion.rgb2xyz;\nvar conversion_2 = conversion.rgb2hsl;\nvar conversion_3 = conversion.rgb2lab;\nvar conversion_4 = conversion.lab2xyz;\nvar conversion_5 = conversion.lab2rgb;\nvar conversion_6 = conversion.xyz2lab;\nvar conversion_7 = conversion.xyz2rgb;\n\nvar distanceCalculator = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar AbstractDistanceCalculator = /** @class */ (function () {\r\n    function AbstractDistanceCalculator() {\r\n        this._setDefaults();\r\n        // set default maximal color component deltas (255 - 0 = 255)\r\n        this.setWhitePoint(255, 255, 255, 255);\r\n    }\r\n    AbstractDistanceCalculator.prototype.setWhitePoint = function (r, g, b, a) {\r\n        this._whitePoint = {\r\n            r: (r > 0) ? 255 / r : 0,\r\n            g: (g > 0) ? 255 / g : 0,\r\n            b: (b > 0) ? 255 / b : 0,\r\n            a: (a > 0) ? 255 / a : 0,\r\n        };\r\n        this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\r\n    };\r\n    AbstractDistanceCalculator.prototype.calculateNormalized = function (colorA, colorB) {\r\n        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\r\n    };\r\n    return AbstractDistanceCalculator;\r\n}());\r\nexports.AbstractDistanceCalculator = AbstractDistanceCalculator;\r\n\n});\n\nunwrapExports(distanceCalculator);\nvar distanceCalculator_1 = distanceCalculator.AbstractDistanceCalculator;\n\nvar cie94 = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cie94.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n/**\r\n * CIE94 method of delta-e\r\n * http://en.wikipedia.org/wiki/Color_difference#CIE94\r\n */\r\nvar AbstractCIE94 = /** @class */ (function (_super) {\r\n    __extends(AbstractCIE94, _super);\r\n    function AbstractCIE94() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AbstractCIE94.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        var lab1 = rgb2lab_1.rgb2lab(arithmetic.inRange0to255(r1 * this._whitePoint.r), arithmetic.inRange0to255(g1 * this._whitePoint.g), arithmetic.inRange0to255(b1 * this._whitePoint.b));\r\n        var lab2 = rgb2lab_1.rgb2lab(arithmetic.inRange0to255(r2 * this._whitePoint.r), arithmetic.inRange0to255(g2 * this._whitePoint.g), arithmetic.inRange0to255(b2 * this._whitePoint.b));\r\n        var dL = lab1.L - lab2.L;\r\n        var dA = lab1.a - lab2.a;\r\n        var dB = lab1.b - lab2.b;\r\n        var c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\r\n        var c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\r\n        var dC = c1 - c2;\r\n        var deltaH = dA * dA + dB * dB - dC * dC;\r\n        deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\r\n        var dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\r\n        // TODO: add alpha channel support\r\n        return Math.sqrt(Math.pow(dL / this._Kl, 2) +\r\n            Math.pow(dC / (1.0 + this._K1 * c1), 2) +\r\n            Math.pow(deltaH / (1.0 + this._K2 * c1), 2) +\r\n            Math.pow(dAlpha, 2));\r\n    };\r\n    return AbstractCIE94;\r\n}(distanceCalculator.AbstractDistanceCalculator));\r\nexports.AbstractCIE94 = AbstractCIE94;\r\nvar CIE94Textiles = /** @class */ (function (_super) {\r\n    __extends(CIE94Textiles, _super);\r\n    function CIE94Textiles() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    CIE94Textiles.prototype._setDefaults = function () {\r\n        this._Kl = 2.0;\r\n        this._K1 = 0.048;\r\n        this._K2 = 0.014;\r\n        this._kA = 0.25 * 50 / 255;\r\n    };\r\n    return CIE94Textiles;\r\n}(AbstractCIE94));\r\nexports.CIE94Textiles = CIE94Textiles;\r\nvar CIE94GraphicArts = /** @class */ (function (_super) {\r\n    __extends(CIE94GraphicArts, _super);\r\n    function CIE94GraphicArts() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    CIE94GraphicArts.prototype._setDefaults = function () {\r\n        this._Kl = 1.0;\r\n        this._K1 = 0.045;\r\n        this._K2 = 0.015;\r\n        this._kA = 0.25 * 100 / 255;\r\n    };\r\n    return CIE94GraphicArts;\r\n}(AbstractCIE94));\r\nexports.CIE94GraphicArts = CIE94GraphicArts;\r\n\n});\n\nunwrapExports(cie94);\nvar cie94_1 = cie94.AbstractCIE94;\nvar cie94_2 = cie94.CIE94Textiles;\nvar cie94_3 = cie94.CIE94GraphicArts;\n\nvar ciede2000 = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ciede2000.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n// tslint:disable:variable-name\r\n// tslint:disable:naming-convention\r\n/**\r\n * CIEDE2000 algorithm - Adapted from Sharma et al\'s MATLAB implementation at\r\n * http://www.ece.rochester.edu/~gsharma/ciede2000/\r\n */\r\nvar CIEDE2000 = /** @class */ (function (_super) {\r\n    __extends(CIEDE2000, _super);\r\n    function CIEDE2000() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    CIEDE2000.prototype._setDefaults = function () { };\r\n    CIEDE2000._calculatehp = function (b, ap) {\r\n        var hp = Math.atan2(b, ap);\r\n        if (hp >= 0)\r\n            return hp;\r\n        return hp + CIEDE2000._deg360InRad;\r\n    };\r\n    CIEDE2000._calculateRT = function (ahp, aCp) {\r\n        var aCp_to_7 = Math.pow(aCp, 7.0);\r\n        var R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)); // 25^7\r\n        var delta_theta = CIEDE2000._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad, 2.0));\r\n        return -Math.sin(2.0 * delta_theta) * R_C;\r\n    };\r\n    CIEDE2000._calculateT = function (ahp) {\r\n        return 1.0 - .17 * Math.cos(ahp - CIEDE2000._deg30InRad) + .24 * Math.cos(ahp * 2.0) + .32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) - .2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad);\r\n    };\r\n    CIEDE2000._calculate_ahp = function (C1pC2p, h_bar, h1p, h2p) {\r\n        var hpSum = h1p + h2p;\r\n        if (C1pC2p === 0)\r\n            return hpSum;\r\n        if (h_bar <= CIEDE2000._deg180InRad)\r\n            return hpSum / 2.0;\r\n        if (hpSum < CIEDE2000._deg360InRad)\r\n            return (hpSum + CIEDE2000._deg360InRad) / 2.0;\r\n        return (hpSum - CIEDE2000._deg360InRad) / 2.0;\r\n    };\r\n    CIEDE2000._calculate_dHp = function (C1pC2p, h_bar, h2p, h1p) {\r\n        var dhp;\r\n        if (C1pC2p === 0) {\r\n            dhp = 0;\r\n        }\r\n        else if (h_bar <= CIEDE2000._deg180InRad) {\r\n            dhp = h2p - h1p;\r\n        }\r\n        else if (h2p <= h1p) {\r\n            dhp = h2p - h1p + CIEDE2000._deg360InRad;\r\n        }\r\n        else {\r\n            dhp = h2p - h1p - CIEDE2000._deg360InRad;\r\n        }\r\n        return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\r\n    };\r\n    CIEDE2000.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        var lab1 = rgb2lab_1.rgb2lab(arithmetic.inRange0to255(r1 * this._whitePoint.r), arithmetic.inRange0to255(g1 * this._whitePoint.g), arithmetic.inRange0to255(b1 * this._whitePoint.b));\r\n        var lab2 = rgb2lab_1.rgb2lab(arithmetic.inRange0to255(r2 * this._whitePoint.r), arithmetic.inRange0to255(g2 * this._whitePoint.g), arithmetic.inRange0to255(b2 * this._whitePoint.b));\r\n        var dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA;\r\n        var dE2 = this.calculateRawInLab(lab1, lab2);\r\n        return Math.sqrt(dE2 + dA * dA);\r\n    };\r\n    CIEDE2000.prototype.calculateRawInLab = function (Lab1, Lab2) {\r\n        // Get L,a,b values for color 1\r\n        var L1 = Lab1.L;\r\n        var a1 = Lab1.a;\r\n        var b1 = Lab1.b;\r\n        // Get L,a,b values for color 2\r\n        var L2 = Lab2.L;\r\n        var a2 = Lab2.a;\r\n        var b2 = Lab2.b;\r\n        // Calculate Cprime1, Cprime2, Cabbar\r\n        var C1 = Math.sqrt(a1 * a1 + b1 * b1);\r\n        var C2 = Math.sqrt(a2 * a2 + b2 * b2);\r\n        var pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2.0, 7.0);\r\n        var G = 0.5 * (1.0 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))); // 25^7\r\n        var a1p = (1.0 + G) * a1;\r\n        var a2p = (1.0 + G) * a2;\r\n        var C1p = Math.sqrt(a1p * a1p + b1 * b1);\r\n        var C2p = Math.sqrt(a2p * a2p + b2 * b2);\r\n        var C1pC2p = C1p * C2p;\r\n        // Angles in Degree.\r\n        var h1p = CIEDE2000._calculatehp(b1, a1p);\r\n        var h2p = CIEDE2000._calculatehp(b2, a2p);\r\n        var h_bar = Math.abs(h1p - h2p);\r\n        var dLp = L2 - L1;\r\n        var dCp = C2p - C1p;\r\n        var dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\r\n        var ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\r\n        var T = CIEDE2000._calculateT(ahp);\r\n        var aCp = (C1p + C2p) / 2.0;\r\n        var aLp_minus_50_square = Math.pow((L1 + L2) / 2.0 - 50.0, 2.0);\r\n        var S_L = 1.0 + (.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square);\r\n        var S_C = 1.0 + .045 * aCp;\r\n        var S_H = 1.0 + .015 * T * aCp;\r\n        var R_T = CIEDE2000._calculateRT(ahp, aCp);\r\n        var dLpSL = dLp / S_L; // S_L * kL, where kL is 1.0\r\n        var dCpSC = dCp / S_C; // S_C * kC, where kC is 1.0\r\n        var dHpSH = dHp / S_H; // S_H * kH, where kH is 1.0\r\n        return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;\r\n    };\r\n    /**\r\n     * Weight in distance: 0.25\r\n     * Max DeltaE: 100\r\n     * Max DeltaA: 255\r\n     */\r\n    CIEDE2000._kA = 0.25 * 100 / 255;\r\n    CIEDE2000._pow25to7 = Math.pow(25, 7);\r\n    CIEDE2000._deg360InRad = arithmetic.degrees2radians(360);\r\n    CIEDE2000._deg180InRad = arithmetic.degrees2radians(180);\r\n    CIEDE2000._deg30InRad = arithmetic.degrees2radians(30);\r\n    CIEDE2000._deg6InRad = arithmetic.degrees2radians(6);\r\n    CIEDE2000._deg63InRad = arithmetic.degrees2radians(63);\r\n    CIEDE2000._deg275InRad = arithmetic.degrees2radians(275);\r\n    CIEDE2000._deg25InRad = arithmetic.degrees2radians(25);\r\n    return CIEDE2000;\r\n}(distanceCalculator.AbstractDistanceCalculator));\r\nexports.CIEDE2000 = CIEDE2000;\r\n\n});\n\nunwrapExports(ciede2000);\nvar ciede2000_1 = ciede2000.CIEDE2000;\n\nvar cmetric = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cmetric.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * TODO: Name it: http://www.compuphase.com/cmetric.htm\r\n */\r\nvar CMetric = /** @class */ (function (_super) {\r\n    __extends(CMetric, _super);\r\n    function CMetric() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    CMetric.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        var rmean = (r1 + r2) / 2 * this._whitePoint.r;\r\n        var r = (r1 - r2) * this._whitePoint.r;\r\n        var g = (g1 - g2) * this._whitePoint.g;\r\n        var b = (b1 - b2) * this._whitePoint.b;\r\n        var dE = ((((512 + rmean) * r * r) >> 8) + 4 * g * g + (((767 - rmean) * b * b) >> 8));\r\n        var dA = (a2 - a1) * this._whitePoint.a;\r\n        return Math.sqrt(dE + dA * dA);\r\n    };\r\n    CMetric.prototype._setDefaults = function () { };\r\n    return CMetric;\r\n}(distanceCalculator.AbstractDistanceCalculator));\r\nexports.CMetric = CMetric;\r\n\n});\n\nunwrapExports(cmetric);\nvar cmetric_1 = cmetric.CMetric;\n\nvar euclidean = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * euclidean.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n/**\r\n * Euclidean color distance\r\n */\r\nvar AbstractEuclidean = /** @class */ (function (_super) {\r\n    __extends(AbstractEuclidean, _super);\r\n    function AbstractEuclidean() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AbstractEuclidean.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        var dR = r2 - r1;\r\n        var dG = g2 - g1;\r\n        var dB = b2 - b1;\r\n        var dA = a2 - a1;\r\n        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\r\n    };\r\n    return AbstractEuclidean;\r\n}(distanceCalculator.AbstractDistanceCalculator));\r\nexports.AbstractEuclidean = AbstractEuclidean;\r\nvar Euclidean = /** @class */ (function (_super) {\r\n    __extends(Euclidean, _super);\r\n    function Euclidean() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Euclidean.prototype._setDefaults = function () {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    };\r\n    return Euclidean;\r\n}(AbstractEuclidean));\r\nexports.Euclidean = Euclidean;\r\n/**\r\n * Euclidean color distance (RGBQuant modification w Alpha)\r\n */\r\nvar EuclideanBT709 = /** @class */ (function (_super) {\r\n    __extends(EuclideanBT709, _super);\r\n    function EuclideanBT709() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    EuclideanBT709.prototype._setDefaults = function () {\r\n        this._kR = bt709.Y.RED;\r\n        this._kG = bt709.Y.GREEN;\r\n        this._kB = bt709.Y.BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    };\r\n    return EuclideanBT709;\r\n}(AbstractEuclidean));\r\nexports.EuclideanBT709 = EuclideanBT709;\r\n/**\r\n * Euclidean color distance (RGBQuant modification w/o Alpha)\r\n */\r\nvar EuclideanBT709NoAlpha = /** @class */ (function (_super) {\r\n    __extends(EuclideanBT709NoAlpha, _super);\r\n    function EuclideanBT709NoAlpha() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    EuclideanBT709NoAlpha.prototype._setDefaults = function () {\r\n        this._kR = bt709.Y.RED;\r\n        this._kG = bt709.Y.GREEN;\r\n        this._kB = bt709.Y.BLUE;\r\n        this._kA = 0;\r\n    };\r\n    return EuclideanBT709NoAlpha;\r\n}(AbstractEuclidean));\r\nexports.EuclideanBT709NoAlpha = EuclideanBT709NoAlpha;\r\n\n});\n\nunwrapExports(euclidean);\nvar euclidean_1 = euclidean.AbstractEuclidean;\nvar euclidean_2 = euclidean.Euclidean;\nvar euclidean_3 = euclidean.EuclideanBT709;\nvar euclidean_4 = euclidean.EuclideanBT709NoAlpha;\n\nvar manhattan = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * manhattanNeuQuant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n/**\r\n * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\r\n */\r\nvar AbstractManhattan = /** @class */ (function (_super) {\r\n    __extends(AbstractManhattan, _super);\r\n    function AbstractManhattan() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AbstractManhattan.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        var dR = r2 - r1;\r\n        var dG = g2 - g1;\r\n        var dB = b2 - b1;\r\n        var dA = a2 - a1;\r\n        if (dR < 0)\r\n            dR = 0 - dR;\r\n        if (dG < 0)\r\n            dG = 0 - dG;\r\n        if (dB < 0)\r\n            dB = 0 - dB;\r\n        if (dA < 0)\r\n            dA = 0 - dA;\r\n        return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\r\n    };\r\n    return AbstractManhattan;\r\n}(distanceCalculator.AbstractDistanceCalculator));\r\nexports.AbstractManhattan = AbstractManhattan;\r\nvar Manhattan = /** @class */ (function (_super) {\r\n    __extends(Manhattan, _super);\r\n    function Manhattan() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Manhattan.prototype._setDefaults = function () {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    };\r\n    return Manhattan;\r\n}(AbstractManhattan));\r\nexports.Manhattan = Manhattan;\r\n/**\r\n * Manhattan distance (Nommyde modification)\r\n * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\r\n */\r\nvar ManhattanNommyde = /** @class */ (function (_super) {\r\n    __extends(ManhattanNommyde, _super);\r\n    function ManhattanNommyde() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ManhattanNommyde.prototype._setDefaults = function () {\r\n        this._kR = 0.4984;\r\n        this._kG = 0.8625;\r\n        this._kB = 0.2979;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    };\r\n    return ManhattanNommyde;\r\n}(AbstractManhattan));\r\nexports.ManhattanNommyde = ManhattanNommyde;\r\n/**\r\n * Manhattan distance (sRGB coefficients)\r\n */\r\nvar ManhattanBT709 = /** @class */ (function (_super) {\r\n    __extends(ManhattanBT709, _super);\r\n    function ManhattanBT709() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ManhattanBT709.prototype._setDefaults = function () {\r\n        this._kR = bt709.Y.RED;\r\n        this._kG = bt709.Y.GREEN;\r\n        this._kB = bt709.Y.BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    };\r\n    return ManhattanBT709;\r\n}(AbstractManhattan));\r\nexports.ManhattanBT709 = ManhattanBT709;\r\n\n});\n\nunwrapExports(manhattan);\nvar manhattan_1 = manhattan.AbstractManhattan;\nvar manhattan_2 = manhattan.Manhattan;\nvar manhattan_3 = manhattan.ManhattanNommyde;\nvar manhattan_4 = manhattan.ManhattanBT709;\n\nvar pngQuant = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pngQuant.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * TODO: check quality of this distance equation\r\n * TODO: ask author for usage rights\r\n * taken from:\r\n * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\r\n * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\r\n */\r\nvar PNGQuant = /** @class */ (function (_super) {\r\n    __extends(PNGQuant, _super);\r\n    function PNGQuant() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Author\'s comments\r\n     * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\r\n     * px_b.a   = px.a   + 1*(1-px.a)\r\n     * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\r\n     * px_w.a   = px.a   + 1*(1-px.a)\r\n     *\r\n     * px_b.rgb = px.rgb              // difference same as in opaque RGB\r\n     * px_b.a   = 1\r\n     * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\r\n     * px_w.a   = 1\r\n     *\r\n     * (px.rgb - px.a) - (py.rgb - py.a)\r\n     * (px.rgb - py.rgb) + (py.a - px.a)\r\n     *\r\n     */\r\n    PNGQuant.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        var alphas = (a2 - a1) * this._whitePoint.a;\r\n        return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) +\r\n            this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) +\r\n            this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\r\n    };\r\n    PNGQuant.prototype._colordifferenceCh = function (x, y, alphas) {\r\n        // maximum of channel blended on white, and blended on black\r\n        // premultiplied alpha and backgrounds 0/1 shorten the formula\r\n        var black = x - y;\r\n        var white = black + alphas;\r\n        return black * black + white * white;\r\n    };\r\n    PNGQuant.prototype._setDefaults = function () { };\r\n    return PNGQuant;\r\n}(distanceCalculator.AbstractDistanceCalculator));\r\nexports.PNGQuant = PNGQuant;\r\n\n});\n\nunwrapExports(pngQuant);\nvar pngQuant_1 = pngQuant.PNGQuant;\n\nvar distance = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\nexports.AbstractDistanceCalculator = distanceCalculator.AbstractDistanceCalculator;\r\n\r\nexports.CIE94Textiles = cie94.CIE94Textiles;\r\nexports.CIE94GraphicArts = cie94.CIE94GraphicArts;\r\n\r\nexports.CIEDE2000 = ciede2000.CIEDE2000;\r\n\r\nexports.CMetric = cmetric.CMetric;\r\n\r\nexports.AbstractEuclidean = euclidean.AbstractEuclidean;\r\nexports.Euclidean = euclidean.Euclidean;\r\nexports.EuclideanBT709NoAlpha = euclidean.EuclideanBT709NoAlpha;\r\nexports.EuclideanBT709 = euclidean.EuclideanBT709;\r\n\r\nexports.AbstractManhattan = manhattan.AbstractManhattan;\r\nexports.Manhattan = manhattan.Manhattan;\r\nexports.ManhattanBT709 = manhattan.ManhattanBT709;\r\nexports.ManhattanNommyde = manhattan.ManhattanNommyde;\r\n\r\nexports.PNGQuant = pngQuant.PNGQuant;\r\n\n});\n\nunwrapExports(distance);\nvar distance_1 = distance.AbstractDistanceCalculator;\nvar distance_2 = distance.CIE94Textiles;\nvar distance_3 = distance.CIE94GraphicArts;\nvar distance_4 = distance.CIEDE2000;\nvar distance_5 = distance.CMetric;\nvar distance_6 = distance.AbstractEuclidean;\nvar distance_7 = distance.Euclidean;\nvar distance_8 = distance.EuclideanBT709NoAlpha;\nvar distance_9 = distance.EuclideanBT709;\nvar distance_10 = distance.AbstractManhattan;\nvar distance_11 = distance.Manhattan;\nvar distance_12 = distance.ManhattanBT709;\nvar distance_13 = distance.ManhattanNommyde;\nvar distance_14 = distance.PNGQuant;\n\nvar paletteQuantizer = createCommonjsModule(function (module, exports) {\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar AbstractPaletteQuantizer = /** @class */ (function () {\r\n    function AbstractPaletteQuantizer() {\r\n    }\r\n    AbstractPaletteQuantizer.prototype.quantizeSync = function () {\r\n        try {\r\n            for (var _a = __values(this.quantize()), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var value = _b.value;\r\n                if (value.palette) {\r\n                    return value.palette;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        throw new Error(\'unreachable\');\r\n        var e_1, _c;\r\n    };\r\n    return AbstractPaletteQuantizer;\r\n}());\r\nexports.AbstractPaletteQuantizer = AbstractPaletteQuantizer;\r\n\n});\n\nunwrapExports(paletteQuantizer);\nvar paletteQuantizer_1 = paletteQuantizer.AbstractPaletteQuantizer;\n\nvar point = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * point.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * v8 optimized class\r\n * 1) "constructor" should have initialization with worst types\r\n * 2) "set" should have |0 / >>> 0\r\n */\r\nvar Point = /** @class */ (function () {\r\n    function Point() {\r\n        this.uint32 = -1 >>> 0;\r\n        this.r = this.g = this.b = this.a = 0;\r\n        this.rgba = new Array(4);\r\n        this.rgba[0] = 0;\r\n        this.rgba[1] = 0;\r\n        this.rgba[2] = 0;\r\n        this.rgba[3] = 0;\r\n        /*\r\n         this.Lab = {\r\n         L : 0.0,\r\n         a : 0.0,\r\n         b : 0.0\r\n         };\r\n         */\r\n    }\r\n    // Lab : { L : number; a : number; b : number };\r\n    Point.createByQuadruplet = function (quadruplet) {\r\n        var point = new Point();\r\n        point.r = quadruplet[0] | 0;\r\n        point.g = quadruplet[1] | 0;\r\n        point.b = quadruplet[2] | 0;\r\n        point.a = quadruplet[3] | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        // point._loadLab();\r\n        return point;\r\n    };\r\n    Point.createByRGBA = function (red, green, blue, alpha) {\r\n        var point = new Point();\r\n        point.r = red | 0;\r\n        point.g = green | 0;\r\n        point.b = blue | 0;\r\n        point.a = alpha | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        // point._loadLab();\r\n        return point;\r\n    };\r\n    Point.createByUint32 = function (uint32) {\r\n        var point = new Point();\r\n        point.uint32 = uint32 >>> 0;\r\n        point._loadRGBA();\r\n        point._loadQuadruplet();\r\n        // point._loadLab();\r\n        return point;\r\n    };\r\n    Point.prototype.from = function (point) {\r\n        this.r = point.r;\r\n        this.g = point.g;\r\n        this.b = point.b;\r\n        this.a = point.a;\r\n        this.uint32 = point.uint32;\r\n        this.rgba[0] = point.r;\r\n        this.rgba[1] = point.g;\r\n        this.rgba[2] = point.b;\r\n        this.rgba[3] = point.a;\r\n        /*\r\n         this.Lab.L = point.Lab.L;\r\n         this.Lab.a = point.Lab.a;\r\n         this.Lab.b = point.Lab.b;\r\n         */\r\n    };\r\n    /*\r\n     * TODO:\r\n     Luminance from RGB:\r\n  \r\n     Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\r\n     Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\r\n     Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\r\n     */\r\n    Point.prototype.getLuminosity = function (useAlphaChannel) {\r\n        var r = this.r;\r\n        var g = this.g;\r\n        var b = this.b;\r\n        if (useAlphaChannel) {\r\n            r = Math.min(255, 255 - this.a + this.a * r / 255);\r\n            g = Math.min(255, 255 - this.a + this.a * g / 255);\r\n            b = Math.min(255, 255 - this.a + this.a * b / 255);\r\n        }\r\n        // var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\r\n        /*\r\n         if(useAlphaChannel) {\r\n         luma = (luma * (255 - this.a)) / 255;\r\n         }\r\n         */\r\n        return r * bt709.Y.RED + g * bt709.Y.GREEN + b * bt709.Y.BLUE;\r\n    };\r\n    Point.prototype._loadUINT32 = function () {\r\n        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\r\n    };\r\n    Point.prototype._loadRGBA = function () {\r\n        this.r = this.uint32 & 0xff;\r\n        this.g = (this.uint32 >>> 8) & 0xff;\r\n        this.b = (this.uint32 >>> 16) & 0xff;\r\n        this.a = (this.uint32 >>> 24) & 0xff;\r\n    };\r\n    Point.prototype._loadQuadruplet = function () {\r\n        this.rgba[0] = this.r;\r\n        this.rgba[1] = this.g;\r\n        this.rgba[2] = this.b;\r\n        this.rgba[3] = this.a;\r\n        /*\r\n         var xyz = rgb2xyz(this.r, this.g, this.b);\r\n         var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\r\n         this.lab.l = lab.l;\r\n         this.lab.a = lab.a;\r\n         this.lab.b = lab.b;\r\n         */\r\n    };\r\n    return Point;\r\n}());\r\nexports.Point = Point;\r\n\n});\n\nunwrapExports(point);\nvar point_1 = point.Point;\n\nvar pointContainer = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pointContainer.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * v8 optimizations done.\r\n * fromXXX methods are static to move out polymorphic code from class instance itself.\r\n */\r\nvar PointContainer = /** @class */ (function () {\r\n    function PointContainer() {\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._pointArray = [];\r\n    }\r\n    PointContainer.prototype.getWidth = function () {\r\n        return this._width;\r\n    };\r\n    PointContainer.prototype.getHeight = function () {\r\n        return this._height;\r\n    };\r\n    PointContainer.prototype.setWidth = function (width) {\r\n        this._width = width;\r\n    };\r\n    PointContainer.prototype.setHeight = function (height) {\r\n        this._height = height;\r\n    };\r\n    PointContainer.prototype.getPointArray = function () {\r\n        return this._pointArray;\r\n    };\r\n    PointContainer.prototype.clone = function () {\r\n        var clone = new PointContainer();\r\n        clone._width = this._width;\r\n        clone._height = this._height;\r\n        for (var i = 0, l = this._pointArray.length; i < l; i++) {\r\n            clone._pointArray[i] = point.Point.createByUint32(this._pointArray[i].uint32 | 0); // "| 0" is added for v8 optimization\r\n        }\r\n        return clone;\r\n    };\r\n    PointContainer.prototype.toUint32Array = function () {\r\n        var l = this._pointArray.length;\r\n        var uint32Array = new Uint32Array(l);\r\n        for (var i = 0; i < l; i++) {\r\n            uint32Array[i] = this._pointArray[i].uint32;\r\n        }\r\n        return uint32Array;\r\n    };\r\n    PointContainer.prototype.toUint8Array = function () {\r\n        return new Uint8Array(this.toUint32Array().buffer);\r\n    };\r\n    PointContainer.fromHTMLImageElement = function (img) {\r\n        var width = img.naturalWidth;\r\n        var height = img.naturalHeight;\r\n        var canvas = document.createElement(\'canvas\');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        var ctx = canvas.getContext(\'2d\'); // tslint:disable-line:no-non-null-assertion\r\n        ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\r\n        return PointContainer.fromHTMLCanvasElement(canvas);\r\n    };\r\n    PointContainer.fromHTMLCanvasElement = function (canvas) {\r\n        var width = canvas.width;\r\n        var height = canvas.height;\r\n        var ctx = canvas.getContext(\'2d\'); // tslint:disable-line:no-non-null-assertion\r\n        var imgData = ctx.getImageData(0, 0, width, height);\r\n        return PointContainer.fromImageData(imgData);\r\n    };\r\n    PointContainer.fromImageData = function (imageData) {\r\n        var width = imageData.width;\r\n        var height = imageData.height;\r\n        return PointContainer.fromUint8Array(imageData.data, width, height);\r\n    };\r\n    PointContainer.fromUint8Array = function (uint8Array, width, height) {\r\n        switch (Object.prototype.toString.call(uint8Array)) {\r\n            case \'[object Uint8ClampedArray]\':\r\n            case \'[object Uint8Array]\':\r\n                break;\r\n            default:\r\n                uint8Array = new Uint8Array(uint8Array);\r\n        }\r\n        var uint32Array = new Uint32Array(uint8Array.buffer);\r\n        return PointContainer.fromUint32Array(uint32Array, width, height);\r\n    };\r\n    PointContainer.fromUint32Array = function (uint32Array, width, height) {\r\n        var container = new PointContainer();\r\n        container._width = width;\r\n        container._height = height;\r\n        for (var i = 0, l = uint32Array.length; i < l; i++) {\r\n            container._pointArray[i] = point.Point.createByUint32(uint32Array[i] | 0); // "| 0" is added for v8 optimization\r\n        }\r\n        return container;\r\n    };\r\n    PointContainer.fromBuffer = function (buffer, width, height) {\r\n        var uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);\r\n        return PointContainer.fromUint32Array(uint32Array, width, height);\r\n    };\r\n    return PointContainer;\r\n}());\r\nexports.PointContainer = PointContainer;\r\n\n});\n\nunwrapExports(pointContainer);\nvar pointContainer_1 = pointContainer.PointContainer;\n\nvar palette = createCommonjsModule(function (module, exports) {\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * palette.ts - part of Image Quantization Library\r\n */\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n\r\n\r\n// TODO: make paletteArray via pointContainer, so, export will be available via pointContainer.exportXXX\r\nvar hueGroups = 10;\r\nfunction hueGroup(hue, segmentsNumber) {\r\n    var maxHue = 360;\r\n    var seg = maxHue / segmentsNumber;\r\n    var half = seg / 2;\r\n    for (var i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\r\n        if (hue >= mid && hue < mid + seg)\r\n            return i;\r\n    }\r\n    return 0;\r\n}\r\nexports.hueGroup = hueGroup;\r\nvar Palette = /** @class */ (function () {\r\n    function Palette() {\r\n        this._pointArray = [];\r\n        this._i32idx = {};\r\n        this._pointContainer = new pointContainer.PointContainer();\r\n        this._pointContainer.setHeight(1);\r\n        this._pointArray = this._pointContainer.getPointArray();\r\n    }\r\n    Palette.prototype.add = function (color) {\r\n        this._pointArray.push(color);\r\n        this._pointContainer.setWidth(this._pointArray.length);\r\n    };\r\n    Palette.prototype.has = function (color) {\r\n        for (var i = this._pointArray.length - 1; i >= 0; i--) {\r\n            if (color.uint32 === this._pointArray[i].uint32)\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\r\n    Palette.prototype.getNearestColor = function (colorDistanceCalculator, color) {\r\n        return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];\r\n    };\r\n    Palette.prototype.getPointContainer = function () {\r\n        return this._pointContainer;\r\n    };\r\n    // TOTRY: use HUSL - http://boronine.com/husl/\r\n    /*\r\n     public nearestIndexByUint32(i32) {\r\n     var idx : number = this._nearestPointFromCache("" + i32);\r\n     if (idx >= 0) return idx;\r\n  \r\n     var min = 1000,\r\n     rgb = [\r\n     (i32 & 0xff),\r\n     (i32 >>> 8) & 0xff,\r\n     (i32 >>> 16) & 0xff,\r\n     (i32 >>> 24) & 0xff\r\n     ],\r\n     len = this._pointArray.length;\r\n  \r\n     idx = 0;\r\n     for (var i = 0; i < len; i++) {\r\n     var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\r\n  \r\n     if (dist < min) {\r\n     min = dist;\r\n     idx = i;\r\n     }\r\n     }\r\n  \r\n     this._i32idx[i32] = idx;\r\n     return idx;\r\n     }\r\n     */\r\n    Palette.prototype._nearestPointFromCache = function (key) {\r\n        return typeof this._i32idx[key] === \'number\' ? this._i32idx[key] : -1;\r\n    };\r\n    Palette.prototype._getNearestIndex = function (colorDistanceCalculator, point) {\r\n        var idx = this._nearestPointFromCache(\'\' + point.uint32);\r\n        if (idx >= 0)\r\n            return idx;\r\n        var minimalDistance = Number.MAX_VALUE;\r\n        idx = 0;\r\n        for (var i = 0, l = this._pointArray.length; i < l; i++) {\r\n            var p = this._pointArray[i];\r\n            var distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\r\n            if (distance < minimalDistance) {\r\n                minimalDistance = distance;\r\n                idx = i;\r\n            }\r\n        }\r\n        this._i32idx[point.uint32] = idx;\r\n        return idx;\r\n    };\r\n    /*\r\n     public reduce(histogram : ColorHistogram, colors : number) {\r\n     if (this._pointArray.length > colors) {\r\n     var idxi32 = histogram.getImportanceSortedColorsIDXI32();\r\n  \r\n     // quantize histogram to existing palette\r\n     var keep = [], uniqueColors = 0, idx, pruned = false;\r\n  \r\n     for (var i = 0, len = idxi32.length; i < len; i++) {\r\n     // palette length reached, unset all remaining colors (sparse palette)\r\n     if (uniqueColors >= colors) {\r\n     this.prunePal(keep);\r\n     pruned = true;\r\n     break;\r\n     } else {\r\n     idx = this.nearestIndexByUint32(idxi32[i]);\r\n     if (keep.indexOf(idx) < 0) {\r\n     keep.push(idx);\r\n     uniqueColors++;\r\n     }\r\n     }\r\n     }\r\n  \r\n     if (!pruned) {\r\n     this.prunePal(keep);\r\n     }\r\n     }\r\n     }\r\n  \r\n     // TODO: check usage, not tested!\r\n     public prunePal(keep : number[]) {\r\n     var colors = this._pointArray.length;\r\n     for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n     if (keep.indexOf(colorIndex) < 0) {\r\n  \r\n     if(colorIndex + 1 < colors) {\r\n     this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\r\n     }\r\n     --colors;\r\n     //this._pointArray[colorIndex] = null;\r\n     }\r\n     }\r\n     console.log("colors pruned: " + (this._pointArray.length - colors));\r\n     this._pointArray.length = colors;\r\n     this._i32idx = {};\r\n     }\r\n     */\r\n    // TODO: group very low lum and very high lum colors\r\n    // TODO: pass custom sort order\r\n    // TODO: sort criteria function should be placed to HueStats class\r\n    Palette.prototype.sort = function () {\r\n        this._i32idx = {};\r\n        this._pointArray.sort(function (a, b) {\r\n            var hslA = rgb2hsl_1.rgb2hsl(a.r, a.g, a.b);\r\n            var hslB = rgb2hsl_1.rgb2hsl(b.r, b.g, b.b);\r\n            // sort all grays + whites together\r\n            var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + hueGroup(hslA.h, hueGroups);\r\n            var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + hueGroup(hslB.h, hueGroups);\r\n            /*\r\n             var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\r\n             var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\r\n             */\r\n            var hueDiff = hueB - hueA;\r\n            if (hueDiff)\r\n                return -hueDiff;\r\n            /*\r\n             var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\r\n             if (lumDiff) return -lumDiff;\r\n             */\r\n            var lA = a.getLuminosity(true);\r\n            var lB = b.getLuminosity(true);\r\n            if (lB - lA !== 0)\r\n                return lB - lA;\r\n            var satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\r\n            if (satDiff)\r\n                return -satDiff;\r\n            return 0;\r\n        });\r\n    };\r\n    return Palette;\r\n}());\r\nexports.Palette = Palette;\r\n\n});\n\nunwrapExports(palette);\nvar palette_1 = palette.hueGroup;\nvar palette_2 = palette.Palette;\n\nvar hueStatistics = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * hueStatistics.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nvar HueGroup = /** @class */ (function () {\r\n    function HueGroup() {\r\n        this.num = 0;\r\n        this.cols = [];\r\n    }\r\n    return HueGroup;\r\n}());\r\nvar HueStatistics = /** @class */ (function () {\r\n    function HueStatistics(numGroups, minCols) {\r\n        this._numGroups = numGroups;\r\n        this._minCols = minCols;\r\n        this._stats = [];\r\n        for (var i = 0; i <= numGroups; i++) {\r\n            this._stats[i] = new HueGroup();\r\n        }\r\n        this._groupsFull = 0;\r\n    }\r\n    HueStatistics.prototype.check = function (i32) {\r\n        if (this._groupsFull === this._numGroups + 1) {\r\n            this.check = function () {\r\n            };\r\n        }\r\n        var r = (i32 & 0xff);\r\n        var g = (i32 >>> 8) & 0xff;\r\n        var b = (i32 >>> 16) & 0xff;\r\n        var hg = (r === g && g === b) ? 0 : 1 + palette.hueGroup(rgb2hsl_1.rgb2hsl(r, g, b).h, this._numGroups);\r\n        var gr = this._stats[hg];\r\n        var min = this._minCols;\r\n        gr.num++;\r\n        if (gr.num > min) {\r\n            return;\r\n        }\r\n        if (gr.num === min) {\r\n            this._groupsFull++;\r\n        }\r\n        if (gr.num <= min) {\r\n            this._stats[hg].cols.push(i32);\r\n        }\r\n    };\r\n    HueStatistics.prototype.injectIntoDictionary = function (histG) {\r\n        for (var i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[i].num <= this._minCols) {\r\n                this._stats[i].cols.forEach(function (col) {\r\n                    if (!histG[col]) {\r\n                        histG[col] = 1;\r\n                    }\r\n                    else {\r\n                        histG[col]++;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    HueStatistics.prototype.injectIntoArray = function (histG) {\r\n        for (var i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[i].num <= this._minCols) {\r\n                this._stats[i].cols.forEach(function (col) {\r\n                    if (histG.indexOf(col) === -1) {\r\n                        histG.push(col);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    return HueStatistics;\r\n}());\r\nexports.HueStatistics = HueStatistics;\r\n\n});\n\nunwrapExports(hueStatistics);\nvar hueStatistics_1 = hueStatistics.HueStatistics;\n\nvar progressTracker = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar ProgressTracker = /** @class */ (function () {\r\n    function ProgressTracker(valueRange, progressRange) {\r\n        this._range = valueRange;\r\n        this._progressRange = progressRange;\r\n        this._step = Math.max(1, this._range / (ProgressTracker.steps + 1) | 0);\r\n        this._last = -this._step;\r\n        this.progress = 0;\r\n    }\r\n    ProgressTracker.prototype.shouldNotify = function (current) {\r\n        if (current - this._last >= this._step) {\r\n            this._last = current;\r\n            this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    ProgressTracker.steps = 100;\r\n    return ProgressTracker;\r\n}());\r\nexports.ProgressTracker = ProgressTracker;\r\n\n});\n\nunwrapExports(progressTracker);\nvar progressTracker_1 = progressTracker.ProgressTracker;\n\nvar utils = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\nexports.arithmetic = arithmetic;\r\n\r\nexports.HueStatistics = hueStatistics.HueStatistics;\r\n\r\nexports.Palette = palette.Palette;\r\n\r\nexports.Point = point.Point;\r\n\r\nexports.PointContainer = pointContainer.PointContainer;\r\n\r\nexports.ProgressTracker = progressTracker.ProgressTracker;\r\n\n});\n\nunwrapExports(utils);\nvar utils_1 = utils.arithmetic;\nvar utils_2 = utils.HueStatistics;\nvar utils_3 = utils.Palette;\nvar utils_4 = utils.Point;\nvar utils_5 = utils.PointContainer;\nvar utils_6 = utils.ProgressTracker;\n\nvar neuquant = createCommonjsModule(function (module, exports) {\n/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * "Kohonen neural networks for optimal colour quantization" in "Network:\r\n * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the "Software"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n// bias for colour values\r\nvar networkBiasShift = 3;\r\nvar Neuron = /** @class */ (function () {\r\n    function Neuron(defaultValue) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    Neuron.prototype.toPoint = function () {\r\n        return point.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    };\r\n    Neuron.prototype.subtract = function (r, g, b, a) {\r\n        this.r -= r | 0;\r\n        this.g -= g | 0;\r\n        this.b -= b | 0;\r\n        this.a -= a | 0;\r\n    };\r\n    return Neuron;\r\n}());\r\nvar NeuQuant = /** @class */ (function (_super) {\r\n    __extends(NeuQuant, _super);\r\n    function NeuQuant(colorDistanceCalculator, colors) {\r\n        if (colors === void 0) { colors = 256; }\r\n        var _this = _super.call(this) || this;\r\n        _this._distance = colorDistanceCalculator;\r\n        _this._pointArray = [];\r\n        _this._sampleFactor = 1;\r\n        _this._networkSize = colors;\r\n        _this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n        return _this;\r\n    }\r\n    NeuQuant.prototype.sample = function (pointContainer) {\r\n        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\r\n    };\r\n    NeuQuant.prototype.quantize = function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    this._init();\r\n                    return [5 /*yield**/, __values(this._learn())];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, {\r\n                            palette: this._buildPalette(),\r\n                            progress: 100,\r\n                        }];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    NeuQuant.prototype._init = function () {\r\n        this._freq = [];\r\n        this._bias = [];\r\n        this._radPower = [];\r\n        this._network = [];\r\n        for (var i = 0; i < this._networkSize; i++) {\r\n            this._network[i] = new Neuron((i << (networkBiasShift + 8)) / this._networkSize | 0);\r\n            // 1/this._networkSize\r\n            this._freq[i] = NeuQuant._initialBias / this._networkSize | 0;\r\n            this._bias[i] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    NeuQuant.prototype._learn = function () {\r\n        var sampleFactor, pointsNumber, alphadec, pointsToSample, delta, alpha, radius, rad, i, step, tracker, i, pointIndex, point$$1, b, g, r, a, neuronIndex, j;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    sampleFactor = this._sampleFactor;\r\n                    pointsNumber = this._pointArray.length;\r\n                    if (pointsNumber < NeuQuant._minpicturebytes)\r\n                        sampleFactor = 1;\r\n                    alphadec = 30 + (sampleFactor - 1) / 3 | 0;\r\n                    pointsToSample = pointsNumber / sampleFactor | 0;\r\n                    delta = pointsToSample / NeuQuant._nCycles | 0;\r\n                    alpha = NeuQuant._initAlpha;\r\n                    radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\r\n                    rad = radius >> NeuQuant._radiusBiasShift;\r\n                    if (rad <= 1)\r\n                        rad = 0;\r\n                    for (i = 0; i < rad; i++) {\r\n                        this._radPower[i] = alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n                    }\r\n                    if (pointsNumber < NeuQuant._minpicturebytes) {\r\n                        step = 1;\r\n                    }\r\n                    else if (pointsNumber % NeuQuant._prime1 !== 0) {\r\n                        step = NeuQuant._prime1;\r\n                    }\r\n                    else if ((pointsNumber % NeuQuant._prime2) !== 0) {\r\n                        step = NeuQuant._prime2;\r\n                    }\r\n                    else if ((pointsNumber % NeuQuant._prime3) !== 0) {\r\n                        step = NeuQuant._prime3;\r\n                    }\r\n                    else {\r\n                        step = NeuQuant._prime4;\r\n                    }\r\n                    tracker = new utils.ProgressTracker(pointsToSample, 99);\r\n                    i = 0, pointIndex = 0;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(i < pointsToSample)) return [3 /*break*/, 5];\r\n                    if (!tracker.shouldNotify(i)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, {\r\n                            progress: tracker.progress,\r\n                        }];\r\n                case 2:\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3:\r\n                    point$$1 = this._pointArray[pointIndex];\r\n                    b = point$$1.b << networkBiasShift;\r\n                    g = point$$1.g << networkBiasShift;\r\n                    r = point$$1.r << networkBiasShift;\r\n                    a = point$$1.a << networkBiasShift;\r\n                    neuronIndex = this._contest(b, g, r, a);\r\n                    this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n                    if (rad !== 0)\r\n                        this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n                    /* alter neighbours */\r\n                    pointIndex += step;\r\n                    if (pointIndex >= pointsNumber)\r\n                        pointIndex -= pointsNumber;\r\n                    i++;\r\n                    if (delta === 0)\r\n                        delta = 1;\r\n                    if (i % delta === 0) {\r\n                        alpha -= (alpha / alphadec) | 0;\r\n                        radius -= (radius / NeuQuant._radiusDecrease) | 0;\r\n                        rad = radius >> NeuQuant._radiusBiasShift;\r\n                        if (rad <= 1)\r\n                            rad = 0;\r\n                        for (j = 0; j < rad; j++)\r\n                            this._radPower[j] = alpha * (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n                    }\r\n                    _a.label = 4;\r\n                case 4: return [3 /*break*/, 1];\r\n                case 5: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    NeuQuant.prototype._buildPalette = function () {\r\n        var palette$$1 = new palette.Palette();\r\n        this._network.forEach(function (neuron) {\r\n            palette$$1.add(neuron.toPoint());\r\n        });\r\n        palette$$1.sort();\r\n        return palette$$1;\r\n    };\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    NeuQuant.prototype._alterNeighbour = function (rad, i, b, g, r, al) {\r\n        var lo = i - rad;\r\n        if (lo < -1)\r\n            lo = -1;\r\n        var hi = i + rad;\r\n        if (hi > this._networkSize)\r\n            hi = this._networkSize;\r\n        var j = i + 1;\r\n        var k = i - 1;\r\n        var m = 1;\r\n        while (j < hi || k > lo) {\r\n            var a = this._radPower[m++] / NeuQuant._alphaRadBias;\r\n            if (j < hi) {\r\n                var p = this._network[j++];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n            if (k > lo) {\r\n                var p = this._network[k--];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    NeuQuant.prototype._alterSingle = function (alpha, i, b, g, r, a) {\r\n        alpha /= NeuQuant._initAlpha;\r\n        /* alter hit neuron */\r\n        var n = this._network[i];\r\n        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\r\n    };\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    NeuQuant.prototype._contest = function (b, g, r, a) {\r\n        var multiplier = (255 * 4) << networkBiasShift;\r\n        var bestd = ~(1 << 31);\r\n        var bestbiasd = bestd;\r\n        var bestpos = -1;\r\n        var bestbiaspos = bestpos;\r\n        for (var i = 0; i < this._networkSize; i++) {\r\n            var n = this._network[i];\r\n            var dist = this._distance.calculateNormalized(n, { r: r, g: g, b: b, a: a }) * multiplier | 0;\r\n            if (dist < bestd) {\r\n                bestd = dist;\r\n                bestpos = i;\r\n            }\r\n            var biasdist = dist - ((this._bias[i]) >> (NeuQuant._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            var betafreq = (this._freq[i] >> NeuQuant._betaShift);\r\n            this._freq[i] -= betafreq;\r\n            this._bias[i] += (betafreq << NeuQuant._gammaShift);\r\n        }\r\n        this._freq[bestpos] += NeuQuant._beta;\r\n        this._bias[bestpos] -= NeuQuant._betaGamma;\r\n        return bestbiaspos;\r\n    };\r\n    /*\r\n     four primes near 500 - assume no image has a length so large\r\n     that it is divisible by all four primes\r\n     */\r\n    NeuQuant._prime1 = 499;\r\n    NeuQuant._prime2 = 491;\r\n    NeuQuant._prime3 = 487;\r\n    NeuQuant._prime4 = 503;\r\n    NeuQuant._minpicturebytes = NeuQuant._prime4;\r\n    // no. of learning cycles\r\n    NeuQuant._nCycles = 100;\r\n    // defs for freq and bias\r\n    NeuQuant._initialBiasShift = 16;\r\n    // bias for fractions\r\n    NeuQuant._initialBias = (1 << NeuQuant._initialBiasShift);\r\n    NeuQuant._gammaShift = 10;\r\n    // gamma = 1024\r\n    // TODO: why gamma is never used?\r\n    // private static _gamma : number     = (1 << NeuQuant._gammaShift);\r\n    NeuQuant._betaShift = 10;\r\n    NeuQuant._beta = (NeuQuant._initialBias >> NeuQuant._betaShift);\r\n    // beta = 1/1024\r\n    NeuQuant._betaGamma = (NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift));\r\n    /*\r\n     * for 256 cols, radius starts\r\n     */\r\n    NeuQuant._radiusBiasShift = 6;\r\n    // at 32.0 biased by 6 bits\r\n    NeuQuant._radiusBias = 1 << NeuQuant._radiusBiasShift;\r\n    // and decreases by a factor of 1/30 each cycle\r\n    NeuQuant._radiusDecrease = 30;\r\n    /* defs for decreasing alpha factor */\r\n    // alpha starts at 1.0\r\n    NeuQuant._alphaBiasShift = 10;\r\n    // biased by 10 bits\r\n    NeuQuant._initAlpha = (1 << NeuQuant._alphaBiasShift);\r\n    /* radBias and alphaRadBias used for radpower calculation */\r\n    NeuQuant._radBiasShift = 8;\r\n    NeuQuant._radBias = 1 << NeuQuant._radBiasShift;\r\n    NeuQuant._alphaRadBiasShift = NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\r\n    NeuQuant._alphaRadBias = 1 << NeuQuant._alphaRadBiasShift;\r\n    return NeuQuant;\r\n}(paletteQuantizer.AbstractPaletteQuantizer));\r\nexports.NeuQuant = NeuQuant;\r\n\n});\n\nunwrapExports(neuquant);\nvar neuquant_1 = neuquant.NeuQuant;\n\nvar neuquantFloat = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/*\r\n * NeuQuantFloat Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * "Kohonen neural networks for optimal colour quantization" in "Network:\r\n * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the "Software"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n// bias for colour values\r\nvar networkBiasShift = 3;\r\nvar NeuronFloat = /** @class */ (function () {\r\n    function NeuronFloat(defaultValue) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    NeuronFloat.prototype.toPoint = function () {\r\n        return point.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    };\r\n    NeuronFloat.prototype.subtract = function (r, g, b, a) {\r\n        this.r -= r;\r\n        this.g -= g;\r\n        this.b -= b;\r\n        this.a -= a;\r\n    };\r\n    return NeuronFloat;\r\n}());\r\nvar NeuQuantFloat = /** @class */ (function (_super) {\r\n    __extends(NeuQuantFloat, _super);\r\n    function NeuQuantFloat(colorDistanceCalculator, colors) {\r\n        if (colors === void 0) { colors = 256; }\r\n        var _this = _super.call(this) || this;\r\n        _this._distance = colorDistanceCalculator;\r\n        _this._pointArray = [];\r\n        _this._sampleFactor = 1;\r\n        _this._networkSize = colors;\r\n        _this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n        return _this;\r\n    }\r\n    NeuQuantFloat.prototype.sample = function (pointContainer) {\r\n        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\r\n    };\r\n    NeuQuantFloat.prototype.quantize = function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    this._init();\r\n                    return [5 /*yield**/, __values(this._learn())];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, {\r\n                            palette: this._buildPalette(),\r\n                            progress: 100,\r\n                        }];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    NeuQuantFloat.prototype._init = function () {\r\n        this._freq = [];\r\n        this._bias = [];\r\n        this._radPower = [];\r\n        this._network = [];\r\n        for (var i = 0; i < this._networkSize; i++) {\r\n            this._network[i] = new NeuronFloat((i << (networkBiasShift + 8)) / this._networkSize);\r\n            // 1/this._networkSize\r\n            this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;\r\n            this._bias[i] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    NeuQuantFloat.prototype._learn = function () {\r\n        var sampleFactor, pointsNumber, alphadec, pointsToSample, delta, alpha, radius, rad, i, step, tracker, i, pointIndex, point$$1, b, g, r, a, neuronIndex, j;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    sampleFactor = this._sampleFactor;\r\n                    pointsNumber = this._pointArray.length;\r\n                    if (pointsNumber < NeuQuantFloat._minpicturebytes)\r\n                        sampleFactor = 1;\r\n                    alphadec = 30 + (sampleFactor - 1) / 3;\r\n                    pointsToSample = pointsNumber / sampleFactor;\r\n                    delta = pointsToSample / NeuQuantFloat._nCycles | 0;\r\n                    alpha = NeuQuantFloat._initAlpha;\r\n                    radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\r\n                    rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n                    if (rad <= 1)\r\n                        rad = 0;\r\n                    for (i = 0; i < rad; i++) {\r\n                        this._radPower[i] = alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\r\n                    }\r\n                    if (pointsNumber < NeuQuantFloat._minpicturebytes) {\r\n                        step = 1;\r\n                    }\r\n                    else if (pointsNumber % NeuQuantFloat._prime1 !== 0) {\r\n                        step = NeuQuantFloat._prime1;\r\n                    }\r\n                    else if ((pointsNumber % NeuQuantFloat._prime2) !== 0) {\r\n                        step = NeuQuantFloat._prime2;\r\n                    }\r\n                    else if ((pointsNumber % NeuQuantFloat._prime3) !== 0) {\r\n                        step = NeuQuantFloat._prime3;\r\n                    }\r\n                    else {\r\n                        step = NeuQuantFloat._prime4;\r\n                    }\r\n                    tracker = new utils.ProgressTracker(pointsToSample, 99);\r\n                    i = 0, pointIndex = 0;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(i < pointsToSample)) return [3 /*break*/, 5];\r\n                    if (!tracker.shouldNotify(i)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, {\r\n                            progress: tracker.progress,\r\n                        }];\r\n                case 2:\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3:\r\n                    point$$1 = this._pointArray[pointIndex];\r\n                    b = point$$1.b << networkBiasShift;\r\n                    g = point$$1.g << networkBiasShift;\r\n                    r = point$$1.r << networkBiasShift;\r\n                    a = point$$1.a << networkBiasShift;\r\n                    neuronIndex = this._contest(b, g, r, a);\r\n                    this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n                    if (rad !== 0)\r\n                        this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n                    /* alter neighbours */\r\n                    pointIndex += step;\r\n                    if (pointIndex >= pointsNumber)\r\n                        pointIndex -= pointsNumber;\r\n                    i++;\r\n                    if (delta === 0)\r\n                        delta = 1;\r\n                    if (i % delta === 0) {\r\n                        alpha -= (alpha / alphadec);\r\n                        radius -= (radius / NeuQuantFloat._radiusDecrease);\r\n                        rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n                        if (rad <= 1)\r\n                            rad = 0;\r\n                        for (j = 0; j < rad; j++)\r\n                            this._radPower[j] = alpha * (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\r\n                    }\r\n                    _a.label = 4;\r\n                case 4: return [3 /*break*/, 1];\r\n                case 5: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    NeuQuantFloat.prototype._buildPalette = function () {\r\n        var palette$$1 = new palette.Palette();\r\n        this._network.forEach(function (neuron) {\r\n            palette$$1.add(neuron.toPoint());\r\n        });\r\n        palette$$1.sort();\r\n        return palette$$1;\r\n    };\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    NeuQuantFloat.prototype._alterNeighbour = function (rad, i, b, g, r, al) {\r\n        var lo = i - rad;\r\n        if (lo < -1)\r\n            lo = -1;\r\n        var hi = i + rad;\r\n        if (hi > this._networkSize)\r\n            hi = this._networkSize;\r\n        var j = i + 1;\r\n        var k = i - 1;\r\n        var m = 1;\r\n        while (j < hi || k > lo) {\r\n            var a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;\r\n            if (j < hi) {\r\n                var p = this._network[j++];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n            if (k > lo) {\r\n                var p = this._network[k--];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    NeuQuantFloat.prototype._alterSingle = function (alpha, i, b, g, r, a) {\r\n        alpha /= NeuQuantFloat._initAlpha;\r\n        /* alter hit neuron */\r\n        var n = this._network[i];\r\n        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\r\n    };\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    NeuQuantFloat.prototype._contest = function (b, g, r, al) {\r\n        var multiplier = (255 * 4) << networkBiasShift;\r\n        var bestd = ~(1 << 31);\r\n        var bestbiasd = bestd;\r\n        var bestpos = -1;\r\n        var bestbiaspos = bestpos;\r\n        for (var i = 0; i < this._networkSize; i++) {\r\n            var n = this._network[i];\r\n            var dist = this._distance.calculateNormalized(n, { r: r, g: g, b: b, a: al }) * multiplier;\r\n            if (dist < bestd) {\r\n                bestd = dist;\r\n                bestpos = i;\r\n            }\r\n            var biasdist = dist - ((this._bias[i]) >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            var betafreq = (this._freq[i] >> NeuQuantFloat._betaShift);\r\n            this._freq[i] -= betafreq;\r\n            this._bias[i] += (betafreq << NeuQuantFloat._gammaShift);\r\n        }\r\n        this._freq[bestpos] += NeuQuantFloat._beta;\r\n        this._bias[bestpos] -= NeuQuantFloat._betaGamma;\r\n        return bestbiaspos;\r\n    };\r\n    /*\r\n     four primes near 500 - assume no image has a length so large\r\n     that it is divisible by all four primes\r\n     */\r\n    NeuQuantFloat._prime1 = 499;\r\n    NeuQuantFloat._prime2 = 491;\r\n    NeuQuantFloat._prime3 = 487;\r\n    NeuQuantFloat._prime4 = 503;\r\n    NeuQuantFloat._minpicturebytes = NeuQuantFloat._prime4;\r\n    // no. of learning cycles\r\n    NeuQuantFloat._nCycles = 100;\r\n    // defs for freq and bias\r\n    NeuQuantFloat._initialBiasShift = 16;\r\n    // bias for fractions\r\n    NeuQuantFloat._initialBias = (1 << NeuQuantFloat._initialBiasShift);\r\n    NeuQuantFloat._gammaShift = 10;\r\n    // gamma = 1024\r\n    // TODO: why gamma is never used?\r\n    // private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\r\n    NeuQuantFloat._betaShift = 10;\r\n    NeuQuantFloat._beta = (NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift);\r\n    // beta = 1/1024\r\n    NeuQuantFloat._betaGamma = (NeuQuantFloat._initialBias << (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift));\r\n    /*\r\n     * for 256 cols, radius starts\r\n     */\r\n    NeuQuantFloat._radiusBiasShift = 6;\r\n    // at 32.0 biased by 6 bits\r\n    NeuQuantFloat._radiusBias = 1 << NeuQuantFloat._radiusBiasShift;\r\n    // and decreases by a factor of 1/30 each cycle\r\n    NeuQuantFloat._radiusDecrease = 30;\r\n    /* defs for decreasing alpha factor */\r\n    // alpha starts at 1.0\r\n    NeuQuantFloat._alphaBiasShift = 10;\r\n    // biased by 10 bits\r\n    NeuQuantFloat._initAlpha = (1 << NeuQuantFloat._alphaBiasShift);\r\n    /* radBias and alphaRadBias used for radpower calculation */\r\n    NeuQuantFloat._radBiasShift = 8;\r\n    NeuQuantFloat._radBias = 1 << NeuQuantFloat._radBiasShift;\r\n    NeuQuantFloat._alphaRadBiasShift = NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\r\n    NeuQuantFloat._alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;\r\n    return NeuQuantFloat;\r\n}(paletteQuantizer.AbstractPaletteQuantizer));\r\nexports.NeuQuantFloat = NeuQuantFloat;\r\n\n});\n\nunwrapExports(neuquantFloat);\nvar neuquantFloat_1 = neuquantFloat.NeuQuantFloat;\n\nvar colorHistogram = createCommonjsModule(function (module, exports) {\n/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ColorHistogram.js - an image quantization lib\r\n */\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * colorHistogram.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nvar ColorHistogram = /** @class */ (function () {\r\n    function ColorHistogram(method, colors) {\r\n        // 1 = by global population, 2 = subregion population threshold\r\n        this._method = method;\r\n        // if > 0, enables hues stats and min-color retention per group\r\n        this._minHueCols = colors << 2; // opts.minHueCols || 0;\r\n        // # of highest-frequency colors to start with for palette reduction\r\n        this._initColors = colors << 2;\r\n        // HueStatistics instance\r\n        this._hueStats = new hueStatistics.HueStatistics(ColorHistogram._hueGroups, this._minHueCols);\r\n        this._histogram = Object.create(null); // tslint:disable-line:no-null-keyword\r\n    }\r\n    ColorHistogram.prototype.sample = function (pointContainer) {\r\n        switch (this._method) {\r\n            case 1:\r\n                this._colorStats1D(pointContainer);\r\n                break;\r\n            case 2:\r\n                this._colorStats2D(pointContainer);\r\n                break;\r\n        }\r\n    };\r\n    ColorHistogram.prototype.getImportanceSortedColorsIDXI32 = function () {\r\n        var _this = this;\r\n        // TODO: fix typing issue in stableSort func\r\n        var sorted = arithmetic.stableSort(Object.keys(this._histogram), function (a, b) { return _this._histogram[b] - _this._histogram[a]; });\r\n        if (sorted.length === 0) {\r\n            return [];\r\n        }\r\n        var idxi32;\r\n        switch (this._method) {\r\n            case 1:\r\n                var initialColorsLimit = Math.min(sorted.length, this._initColors);\r\n                var last = sorted[initialColorsLimit - 1];\r\n                var freq = this._histogram[last];\r\n                idxi32 = sorted.slice(0, initialColorsLimit);\r\n                // add any cut off colors with same freq as last\r\n                var pos = initialColorsLimit;\r\n                var len = sorted.length;\r\n                while (pos < len && this._histogram[sorted[pos]] === freq) {\r\n                    idxi32.push(sorted[pos++]);\r\n                }\r\n                // inject min huegroup colors\r\n                this._hueStats.injectIntoArray(idxi32);\r\n                break;\r\n            case 2:\r\n                idxi32 = sorted;\r\n                break;\r\n            default:\r\n                // TODO: rethink errors\r\n                throw new Error(\'Incorrect method\');\r\n        }\r\n        // int32-ify values\r\n        return idxi32.map(function (v) {\r\n            return +v;\r\n        });\r\n    };\r\n    // global top-population\r\n    ColorHistogram.prototype._colorStats1D = function (pointContainer) {\r\n        var histG = this._histogram;\r\n        var pointArray = pointContainer.getPointArray();\r\n        var len = pointArray.length;\r\n        for (var i = 0; i < len; i++) {\r\n            var col = pointArray[i].uint32;\r\n            // collect hue stats\r\n            this._hueStats.check(col);\r\n            if (col in histG) {\r\n                histG[col]++;\r\n            }\r\n            else {\r\n                histG[col] = 1;\r\n            }\r\n        }\r\n    };\r\n    // population threshold within subregions\r\n    // FIXME: this can over-reduce (few/no colors same?), need a way to keep\r\n    // important colors that dont ever reach local thresholds (gradients?)\r\n    ColorHistogram.prototype._colorStats2D = function (pointContainer) {\r\n        var _this = this;\r\n        var width = pointContainer.getWidth();\r\n        var height = pointContainer.getHeight();\r\n        var pointArray = pointContainer.getPointArray();\r\n        var boxW = ColorHistogram._boxSize[0];\r\n        var boxH = ColorHistogram._boxSize[1];\r\n        var area = boxW * boxH;\r\n        var boxes = this._makeBoxes(width, height, boxW, boxH);\r\n        var histG = this._histogram;\r\n        boxes.forEach(function (box) {\r\n            var effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\r\n            if (effc < 2)\r\n                effc = 2;\r\n            var histL = {};\r\n            _this._iterateBox(box, width, function (i) {\r\n                var col = pointArray[i].uint32;\r\n                // collect hue stats\r\n                _this._hueStats.check(col);\r\n                if (col in histG) {\r\n                    histG[col]++;\r\n                }\r\n                else if (col in histL) {\r\n                    if (++histL[col] >= effc) {\r\n                        histG[col] = histL[col];\r\n                    }\r\n                }\r\n                else {\r\n                    histL[col] = 1;\r\n                }\r\n            });\r\n        });\r\n        // inject min huegroup colors\r\n        this._hueStats.injectIntoDictionary(histG);\r\n    };\r\n    // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\r\n    ColorHistogram.prototype._iterateBox = function (bbox, wid, fn) {\r\n        var b = bbox;\r\n        var i0 = b.y * wid + b.x;\r\n        var i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\r\n        var incr = wid - b.w + 1;\r\n        var cnt = 0;\r\n        var i = i0;\r\n        do {\r\n            fn.call(this, i);\r\n            i += (++cnt % b.w === 0) ? incr : 1;\r\n        } while (i <= i1);\r\n    };\r\n    /**\r\n     *    partitions a rectangle of width x height into\r\n     *    array of boxes stepX x stepY (or less)\r\n     */\r\n    ColorHistogram.prototype._makeBoxes = function (width, height, stepX, stepY) {\r\n        var wrem = width % stepX;\r\n        var hrem = height % stepY;\r\n        var xend = width - wrem;\r\n        var yend = height - hrem;\r\n        var boxesArray = [];\r\n        for (var y = 0; y < height; y += stepY) {\r\n            for (var x = 0; x < width; x += stepX) {\r\n                boxesArray.push({ x: x, y: y, w: (x === xend ? wrem : stepX), h: (y === yend ? hrem : stepY) });\r\n            }\r\n        }\r\n        return boxesArray;\r\n    };\r\n    ColorHistogram._boxSize = [64, 64];\r\n    ColorHistogram._boxPixels = 2;\r\n    ColorHistogram._hueGroups = 10;\r\n    return ColorHistogram;\r\n}());\r\nexports.ColorHistogram = ColorHistogram;\r\n\n});\n\nunwrapExports(colorHistogram);\nvar colorHistogram_1 = colorHistogram.ColorHistogram;\n\nvar rgbquant = createCommonjsModule(function (module, exports) {\n/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * RGBQuant.js - an image quantization lib\r\n */\r\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgbquant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar RemovedColor = /** @class */ (function () {\r\n    function RemovedColor(index, color, distance) {\r\n        this.index = index;\r\n        this.color = color;\r\n        this.distance = distance;\r\n    }\r\n    return RemovedColor;\r\n}());\r\n// TODO: make input/output image and input/output palettes with instances of class Point only!\r\nvar RGBQuant = /** @class */ (function (_super) {\r\n    __extends(RGBQuant, _super);\r\n    function RGBQuant(colorDistanceCalculator, colors, method) {\r\n        if (colors === void 0) { colors = 256; }\r\n        if (method === void 0) { method = 2; }\r\n        var _this = _super.call(this) || this;\r\n        _this._distance = colorDistanceCalculator;\r\n        // desired final palette size\r\n        _this._colors = colors;\r\n        // histogram to accumulate\r\n        _this._histogram = new colorHistogram.ColorHistogram(method, colors);\r\n        _this._initialDistance = 0.01;\r\n        _this._distanceIncrement = 0.005;\r\n        return _this;\r\n    }\r\n    // gathers histogram info\r\n    RGBQuant.prototype.sample = function (image) {\r\n        /*\r\n         var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\r\n    \r\n         for (var i = 0, l = pointArray.length; i < l; i++) {\r\n         var color = pointArray[i];\r\n         for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\r\n         if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\r\n         if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\r\n         }\r\n         }\r\n         var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\r\n         this._distance.setWhitePoint(rd, gd, bd, ad);\r\n    \r\n         this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\r\n         */\r\n        this._histogram.sample(image);\r\n    };\r\n    // reduces histogram to palette, remaps & memoizes reduced colors\r\n    RGBQuant.prototype.quantize = function () {\r\n        var idxi32;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\r\n                    if (idxi32.length === 0) {\r\n                        throw new Error(\'No colors in image\');\r\n                    }\r\n                    return [5 /*yield**/, __values(this._buildPalette(idxi32))];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    // reduces similar colors from an importance-sorted Uint32 rgba array\r\n    RGBQuant.prototype._buildPalette = function (idxi32) {\r\n        var palette$$1, colorArray, usageArray, i, len, memDist, palLen, thold, tracker, i, pxi, j, pxj, dist, k, removedColor, colors, colorIndex;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    palette$$1 = new palette.Palette();\r\n                    colorArray = palette$$1.getPointContainer().getPointArray();\r\n                    usageArray = new Array(idxi32.length);\r\n                    for (i = 0; i < idxi32.length; i++) {\r\n                        colorArray.push(point.Point.createByUint32(idxi32[i]));\r\n                        usageArray[i] = 1;\r\n                    }\r\n                    len = colorArray.length;\r\n                    memDist = [];\r\n                    palLen = len;\r\n                    thold = this._initialDistance;\r\n                    tracker = new utils.ProgressTracker(palLen - this._colors, 99);\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(palLen > this._colors)) return [3 /*break*/, 7];\r\n                    memDist.length = 0;\r\n                    i = 0;\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (!(i < len)) return [3 /*break*/, 6];\r\n                    if (!tracker.shouldNotify(len - palLen)) return [3 /*break*/, 4];\r\n                    return [4 /*yield*/, {\r\n                            progress: tracker.progress,\r\n                        }];\r\n                case 3:\r\n                    _a.sent();\r\n                    _a.label = 4;\r\n                case 4:\r\n                    if (usageArray[i] === 0)\r\n                        return [3 /*break*/, 5];\r\n                    pxi = colorArray[i];\r\n                    // if (!pxi) continue;\r\n                    for (j = i + 1; j < len; j++) {\r\n                        if (usageArray[j] === 0)\r\n                            continue;\r\n                        pxj = colorArray[j];\r\n                        dist = this._distance.calculateNormalized(pxi, pxj);\r\n                        if (dist < thold) {\r\n                            // store index,rgb,dist\r\n                            memDist.push(new RemovedColor(j, pxj, dist));\r\n                            usageArray[j] = 0;\r\n                            palLen--;\r\n                        }\r\n                    }\r\n                    _a.label = 5;\r\n                case 5:\r\n                    i++;\r\n                    return [3 /*break*/, 2];\r\n                case 6:\r\n                    // palette reduction pass\r\n                    // console.log("palette length: " + palLen);\r\n                    // if palette is still much larger than target, increment by larger initDist\r\n                    thold += (palLen > this._colors * 3) ? this._initialDistance : this._distanceIncrement;\r\n                    return [3 /*break*/, 1];\r\n                case 7:\r\n                    // if palette is over-reduced, re-add removed colors with largest distances from last round\r\n                    if (palLen < this._colors) {\r\n                        // sort descending\r\n                        arithmetic.stableSort(memDist, function (a, b) {\r\n                            return b.distance - a.distance;\r\n                        });\r\n                        k = 0;\r\n                        while (palLen < this._colors && k < memDist.length) {\r\n                            removedColor = memDist[k];\r\n                            // re-inject rgb into final palette\r\n                            usageArray[removedColor.index] = 1;\r\n                            palLen++;\r\n                            k++;\r\n                        }\r\n                    }\r\n                    colors = colorArray.length;\r\n                    for (colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n                        if (usageArray[colorIndex] === 0) {\r\n                            if (colorIndex !== colors - 1) {\r\n                                colorArray[colorIndex] = colorArray[colors - 1];\r\n                            }\r\n                            --colors;\r\n                        }\r\n                    }\r\n                    colorArray.length = colors;\r\n                    palette$$1.sort();\r\n                    return [4 /*yield*/, {\r\n                            palette: palette$$1,\r\n                            progress: 100,\r\n                        }];\r\n                case 8:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return RGBQuant;\r\n}(paletteQuantizer.AbstractPaletteQuantizer));\r\nexports.RGBQuant = RGBQuant;\r\n\n});\n\nunwrapExports(rgbquant);\nvar rgbquant_1 = rgbquant.RGBQuant;\n\nvar wuQuant = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * wuQuant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\nfunction createArray1D(dimension1) {\r\n    var a = [];\r\n    for (var k = 0; k < dimension1; k++) {\r\n        a[k] = 0;\r\n    }\r\n    return a;\r\n}\r\nfunction createArray4D(dimension1, dimension2, dimension3, dimension4) {\r\n    var a = new Array(dimension1);\r\n    for (var i = 0; i < dimension1; i++) {\r\n        a[i] = new Array(dimension2);\r\n        for (var j = 0; j < dimension2; j++) {\r\n            a[i][j] = new Array(dimension3);\r\n            for (var k = 0; k < dimension3; k++) {\r\n                a[i][j][k] = new Array(dimension4);\r\n                for (var l = 0; l < dimension4; l++) {\r\n                    a[i][j][k][l] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\nfunction createArray3D(dimension1, dimension2, dimension3) {\r\n    var a = new Array(dimension1);\r\n    for (var i = 0; i < dimension1; i++) {\r\n        a[i] = new Array(dimension2);\r\n        for (var j = 0; j < dimension2; j++) {\r\n            a[i][j] = new Array(dimension3);\r\n            for (var k = 0; k < dimension3; k++) {\r\n                a[i][j][k] = 0;\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\nfunction fillArray3D(a, dimension1, dimension2, dimension3, value) {\r\n    for (var i = 0; i < dimension1; i++) {\r\n        a[i] = [];\r\n        for (var j = 0; j < dimension2; j++) {\r\n            a[i][j] = [];\r\n            for (var k = 0; k < dimension3; k++) {\r\n                a[i][j][k] = value;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction fillArray1D(a, dimension1, value) {\r\n    for (var i = 0; i < dimension1; i++) {\r\n        a[i] = value;\r\n    }\r\n}\r\nvar WuColorCube = /** @class */ (function () {\r\n    function WuColorCube() {\r\n    }\r\n    return WuColorCube;\r\n}());\r\nexports.WuColorCube = WuColorCube;\r\nvar WuQuant = /** @class */ (function (_super) {\r\n    __extends(WuQuant, _super);\r\n    function WuQuant(colorDistanceCalculator, colors, significantBitsPerChannel) {\r\n        if (colors === void 0) { colors = 256; }\r\n        if (significantBitsPerChannel === void 0) { significantBitsPerChannel = 5; }\r\n        var _this = _super.call(this) || this;\r\n        _this._distance = colorDistanceCalculator;\r\n        _this._setQuality(significantBitsPerChannel);\r\n        _this._initialize(colors);\r\n        return _this;\r\n    }\r\n    WuQuant.prototype.sample = function (image) {\r\n        var pointArray = image.getPointArray();\r\n        for (var i = 0, l = pointArray.length; i < l; i++) {\r\n            this._addColor(pointArray[i]);\r\n        }\r\n        this._pixels = this._pixels.concat(pointArray);\r\n    };\r\n    WuQuant.prototype.quantize = function () {\r\n        var palette$$1, paletteIndex, sum, r, g, b, a, color;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [5 /*yield**/, __values(this._preparePalette())];\r\n                case 1:\r\n                    _a.sent();\r\n                    palette$$1 = new palette.Palette();\r\n                    // generates palette\r\n                    for (paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\r\n                        if (this._sums[paletteIndex] > 0) {\r\n                            sum = this._sums[paletteIndex];\r\n                            r = this._reds[paletteIndex] / sum;\r\n                            g = this._greens[paletteIndex] / sum;\r\n                            b = this._blues[paletteIndex] / sum;\r\n                            a = this._alphas[paletteIndex] / sum;\r\n                            color = point.Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\r\n                            palette$$1.add(color);\r\n                        }\r\n                    }\r\n                    palette$$1.sort();\r\n                    return [4 /*yield*/, {\r\n                            palette: palette$$1,\r\n                            progress: 100,\r\n                        }];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    WuQuant.prototype._preparePalette = function () {\r\n        var next, volumeVariance, cubeIndex, temp, index, lookupRed, lookupGreen, lookupBlue, lookupAlpha, k, weight, index, l, color, match, bestMatch, bestDistance, lookup, foundRed, foundGreen, foundBlue, foundAlpha, distance;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: \r\n                // preprocess the colors\r\n                return [5 /*yield**/, __values(this._calculateMoments())];\r\n                case 1:\r\n                    // preprocess the colors\r\n                    _a.sent();\r\n                    next = 0;\r\n                    volumeVariance = createArray1D(this._colors);\r\n                    // processes the cubes\r\n                    for (cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\r\n                        // if cut is possible; make it\r\n                        if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\r\n                            volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0.0;\r\n                            volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0.0;\r\n                        }\r\n                        else {\r\n                            // the cut was not possible, revert the index\r\n                            volumeVariance[next] = 0.0;\r\n                            cubeIndex--;\r\n                        }\r\n                        next = 0;\r\n                        temp = volumeVariance[0];\r\n                        for (index = 1; index <= cubeIndex; ++index) {\r\n                            if (volumeVariance[index] > temp) {\r\n                                temp = volumeVariance[index];\r\n                                next = index;\r\n                            }\r\n                        }\r\n                        if (temp <= 0.0) {\r\n                            this._colors = cubeIndex + 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                    lookupRed = [];\r\n                    lookupGreen = [];\r\n                    lookupBlue = [];\r\n                    lookupAlpha = [];\r\n                    // precalculates lookup tables\r\n                    for (k = 0; k < this._colors; ++k) {\r\n                        weight = WuQuant._volume(this._cubes[k], this._weights);\r\n                        if (weight > 0) {\r\n                            lookupRed[k] = (WuQuant._volume(this._cubes[k], this._momentsRed) / weight) | 0;\r\n                            lookupGreen[k] = (WuQuant._volume(this._cubes[k], this._momentsGreen) / weight) | 0;\r\n                            lookupBlue[k] = (WuQuant._volume(this._cubes[k], this._momentsBlue) / weight) | 0;\r\n                            lookupAlpha[k] = (WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight) | 0;\r\n                        }\r\n                        else {\r\n                            lookupRed[k] = 0;\r\n                            lookupGreen[k] = 0;\r\n                            lookupBlue[k] = 0;\r\n                            lookupAlpha[k] = 0;\r\n                        }\r\n                    }\r\n                    this._reds = createArray1D(this._colors + 1);\r\n                    this._greens = createArray1D(this._colors + 1);\r\n                    this._blues = createArray1D(this._colors + 1);\r\n                    this._alphas = createArray1D(this._colors + 1);\r\n                    this._sums = createArray1D(this._colors + 1);\r\n                    // scans and adds colors\r\n                    for (index = 0, l = this._pixels.length; index < l; index++) {\r\n                        color = this._pixels[index];\r\n                        match = -1;\r\n                        bestMatch = match;\r\n                        bestDistance = Number.MAX_VALUE;\r\n                        for (lookup = 0; lookup < this._colors; lookup++) {\r\n                            foundRed = lookupRed[lookup];\r\n                            foundGreen = lookupGreen[lookup];\r\n                            foundBlue = lookupBlue[lookup];\r\n                            foundAlpha = lookupAlpha[lookup];\r\n                            distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\r\n                            if (distance < bestDistance) {\r\n                                bestDistance = distance;\r\n                                bestMatch = lookup;\r\n                            }\r\n                        }\r\n                        this._reds[bestMatch] += color.r;\r\n                        this._greens[bestMatch] += color.g;\r\n                        this._blues[bestMatch] += color.b;\r\n                        this._alphas[bestMatch] += color.a;\r\n                        this._sums[bestMatch]++;\r\n                    }\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    WuQuant.prototype._addColor = function (color) {\r\n        var bitsToRemove = 8 - this._significantBitsPerChannel;\r\n        var indexRed = (color.r >> bitsToRemove) + 1;\r\n        var indexGreen = (color.g >> bitsToRemove) + 1;\r\n        var indexBlue = (color.b >> bitsToRemove) + 1;\r\n        var indexAlpha = (color.a >> bitsToRemove) + 1;\r\n        // if(color.a > 10) {\r\n        this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\r\n        this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\r\n        this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\r\n        this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\r\n        this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\r\n        this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];\r\n        // }\r\n    };\r\n    /**\r\n     * Converts the histogram to a series of _moments.\r\n     */\r\n    WuQuant.prototype._calculateMoments = function () {\r\n        var area, areaRed, areaGreen, areaBlue, areaAlpha, area2, xarea, xareaRed, xareaGreen, xareaBlue, xareaAlpha, xarea2, trackerProgress, tracker, alphaIndex, redIndex, greenIndex, line, lineRed, lineGreen, lineBlue, lineAlpha, line2, blueIndex;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    area = [];\r\n                    areaRed = [];\r\n                    areaGreen = [];\r\n                    areaBlue = [];\r\n                    areaAlpha = [];\r\n                    area2 = [];\r\n                    xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n                    xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n                    xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n                    xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n                    xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n                    xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n                    trackerProgress = 0;\r\n                    tracker = new utils.ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);\r\n                    alphaIndex = 1;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(alphaIndex <= this._alphaMaxSideIndex)) return [3 /*break*/, 7];\r\n                    fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\r\n                    fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\r\n                    fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\r\n                    fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\r\n                    fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\r\n                    fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\r\n                    redIndex = 1;\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (!(redIndex <= this._maxSideIndex)) return [3 /*break*/, 6];\r\n                    if (!tracker.shouldNotify(trackerProgress)) return [3 /*break*/, 4];\r\n                    return [4 /*yield*/, {\r\n                            progress: tracker.progress,\r\n                        }];\r\n                case 3:\r\n                    _a.sent();\r\n                    _a.label = 4;\r\n                case 4:\r\n                    fillArray1D(area, this._sideSize, 0);\r\n                    fillArray1D(areaRed, this._sideSize, 0);\r\n                    fillArray1D(areaGreen, this._sideSize, 0);\r\n                    fillArray1D(areaBlue, this._sideSize, 0);\r\n                    fillArray1D(areaAlpha, this._sideSize, 0);\r\n                    fillArray1D(area2, this._sideSize, 0);\r\n                    for (greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\r\n                        line = 0;\r\n                        lineRed = 0;\r\n                        lineGreen = 0;\r\n                        lineBlue = 0;\r\n                        lineAlpha = 0;\r\n                        line2 = 0.0;\r\n                        for (blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\r\n                            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                            area[blueIndex] += line;\r\n                            areaRed[blueIndex] += lineRed;\r\n                            areaGreen[blueIndex] += lineGreen;\r\n                            areaBlue[blueIndex] += lineBlue;\r\n                            areaAlpha[blueIndex] += lineAlpha;\r\n                            area2[blueIndex] += line2;\r\n                            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\r\n                            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];\r\n                            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];\r\n                            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];\r\n                            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];\r\n                            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\r\n                            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];\r\n                            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];\r\n                            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];\r\n                            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];\r\n                            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];\r\n                            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];\r\n                        }\r\n                    }\r\n                    _a.label = 5;\r\n                case 5:\r\n                    ++redIndex, ++trackerProgress;\r\n                    return [3 /*break*/, 2];\r\n                case 6:\r\n                    ++alphaIndex;\r\n                    return [3 /*break*/, 1];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    WuQuant._volumeFloat = function (cube, moment) {\r\n        return (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] -\r\n            moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -\r\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +\r\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] -\r\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] +\r\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +\r\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -\r\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n            (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -\r\n                moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -\r\n                moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -\r\n                moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] -\r\n                moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n    };\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    WuQuant._volume = function (cube, moment) {\r\n        return WuQuant._volumeFloat(cube, moment) | 0;\r\n    };\r\n    /**\r\n     * Splits the cube in given position][and color direction.\r\n     */\r\n    WuQuant._top = function (cube, direction, position, moment) {\r\n        var result;\r\n        switch (direction) {\r\n            case WuQuant._alpha:\r\n                result = (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -\r\n                    moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -\r\n                        moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n                break;\r\n            case WuQuant._red:\r\n                result = (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);\r\n                break;\r\n            case WuQuant._green:\r\n                result = (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] -\r\n                    moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum]) -\r\n                    (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] -\r\n                        moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);\r\n                break;\r\n            case WuQuant._blue:\r\n                result = (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] -\r\n                    moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] -\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position]) -\r\n                    (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] -\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);\r\n                break;\r\n            default:\r\n                throw new Error(\'impossible\');\r\n        }\r\n        return result | 0;\r\n    };\r\n    /**\r\n     * Splits the cube in a given color direction at its minimum.\r\n     */\r\n    WuQuant._bottom = function (cube, direction, moment) {\r\n        switch (direction) {\r\n            case WuQuant._alpha:\r\n                return (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            case WuQuant._red:\r\n                return (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            case WuQuant._green:\r\n                return (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            case WuQuant._blue:\r\n                return (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +\r\n                    moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]) -\r\n                    (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            default:\r\n                // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\r\n                return 0;\r\n        }\r\n    };\r\n    /**\r\n     * Calculates statistical variance for a given cube.\r\n     */\r\n    WuQuant.prototype._calculateVariance = function (cube) {\r\n        var volumeRed = WuQuant._volume(cube, this._momentsRed);\r\n        var volumeGreen = WuQuant._volume(cube, this._momentsGreen);\r\n        var volumeBlue = WuQuant._volume(cube, this._momentsBlue);\r\n        var volumeAlpha = WuQuant._volume(cube, this._momentsAlpha);\r\n        var volumeMoment = WuQuant._volumeFloat(cube, this._moments);\r\n        var volumeWeight = WuQuant._volume(cube, this._weights);\r\n        var distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\r\n        return volumeMoment - (distance / volumeWeight);\r\n    };\r\n    /**\r\n     * Finds the optimal (maximal) position for the cut.\r\n     */\r\n    WuQuant.prototype._maximize = function (cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {\r\n        var bottomRed = WuQuant._bottom(cube, direction, this._momentsRed) | 0;\r\n        var bottomGreen = WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\r\n        var bottomBlue = WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\r\n        var bottomAlpha = WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\r\n        var bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\r\n        var result = 0.0;\r\n        var cutPosition = -1;\r\n        for (var position = first; position < last; ++position) {\r\n            // determines the cube cut at a certain position\r\n            var halfRed = bottomRed + WuQuant._top(cube, direction, position, this._momentsRed);\r\n            var halfGreen = bottomGreen + WuQuant._top(cube, direction, position, this._momentsGreen);\r\n            var halfBlue = bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue);\r\n            var halfAlpha = bottomAlpha + WuQuant._top(cube, direction, position, this._momentsAlpha);\r\n            var halfWeight = bottomWeight + WuQuant._top(cube, direction, position, this._weights);\r\n            // the cube cannot be cut at bottom (this would lead to empty cube)\r\n            if (halfWeight !== 0) {\r\n                var halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\r\n                var temp = halfDistance / halfWeight;\r\n                halfRed = wholeRed - halfRed;\r\n                halfGreen = wholeGreen - halfGreen;\r\n                halfBlue = wholeBlue - halfBlue;\r\n                halfAlpha = wholeAlpha - halfAlpha;\r\n                halfWeight = wholeWeight - halfWeight;\r\n                if (halfWeight !== 0) {\r\n                    halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\r\n                    temp += halfDistance / halfWeight;\r\n                    if (temp > result) {\r\n                        result = temp;\r\n                        cutPosition = position;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return { max: result, position: cutPosition };\r\n    };\r\n    // Cuts a cube with another one.\r\n    WuQuant.prototype._cut = function (first, second) {\r\n        var direction;\r\n        var wholeRed = WuQuant._volume(first, this._momentsRed);\r\n        var wholeGreen = WuQuant._volume(first, this._momentsGreen);\r\n        var wholeBlue = WuQuant._volume(first, this._momentsBlue);\r\n        var wholeAlpha = WuQuant._volume(first, this._momentsAlpha);\r\n        var wholeWeight = WuQuant._volume(first, this._weights);\r\n        var red = this._maximize(first, WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        var green = this._maximize(first, WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        var blue = this._maximize(first, WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        var alpha = this._maximize(first, WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\r\n            direction = WuQuant._alpha;\r\n            // cannot split empty cube\r\n            if (alpha.position < 0)\r\n                return false;\r\n        }\r\n        else {\r\n            if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\r\n                direction = WuQuant._red;\r\n            }\r\n            else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\r\n                direction = WuQuant._green;\r\n            }\r\n            else {\r\n                direction = WuQuant._blue;\r\n            }\r\n        }\r\n        second.redMaximum = first.redMaximum;\r\n        second.greenMaximum = first.greenMaximum;\r\n        second.blueMaximum = first.blueMaximum;\r\n        second.alphaMaximum = first.alphaMaximum;\r\n        // cuts in a certain direction\r\n        switch (direction) {\r\n            case WuQuant._red:\r\n                second.redMinimum = first.redMaximum = red.position;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.blueMinimum = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n            case WuQuant._green:\r\n                second.greenMinimum = first.greenMaximum = green.position;\r\n                second.redMinimum = first.redMinimum;\r\n                second.blueMinimum = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n            case WuQuant._blue:\r\n                second.blueMinimum = first.blueMaximum = blue.position;\r\n                second.redMinimum = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n            case WuQuant._alpha:\r\n                second.alphaMinimum = first.alphaMaximum = alpha.position;\r\n                second.blueMinimum = first.blueMinimum;\r\n                second.redMinimum = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                break;\r\n        }\r\n        // determines the volumes after cut\r\n        first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\r\n        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\r\n        // the cut was successful\r\n        return true;\r\n    };\r\n    WuQuant.prototype._initialize = function (colors) {\r\n        this._colors = colors;\r\n        // creates all the _cubes\r\n        this._cubes = [];\r\n        // initializes all the _cubes\r\n        for (var cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\r\n            this._cubes[cubeIndex] = new WuColorCube();\r\n        }\r\n        // resets the reference minimums\r\n        this._cubes[0].redMinimum = 0;\r\n        this._cubes[0].greenMinimum = 0;\r\n        this._cubes[0].blueMinimum = 0;\r\n        this._cubes[0].alphaMinimum = 0;\r\n        // resets the reference maximums\r\n        this._cubes[0].redMaximum = this._maxSideIndex;\r\n        this._cubes[0].greenMaximum = this._maxSideIndex;\r\n        this._cubes[0].blueMaximum = this._maxSideIndex;\r\n        this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\r\n        this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._table = [];\r\n        for (var tableIndex = 0; tableIndex < 256; ++tableIndex) {\r\n            this._table[tableIndex] = tableIndex * tableIndex;\r\n        }\r\n        this._pixels = [];\r\n    };\r\n    WuQuant.prototype._setQuality = function (significantBitsPerChannel) {\r\n        if (significantBitsPerChannel === void 0) { significantBitsPerChannel = 5; }\r\n        this._significantBitsPerChannel = significantBitsPerChannel;\r\n        this._maxSideIndex = 1 << this._significantBitsPerChannel;\r\n        this._alphaMaxSideIndex = this._maxSideIndex;\r\n        this._sideSize = this._maxSideIndex + 1;\r\n        this._alphaSideSize = this._alphaMaxSideIndex + 1;\r\n    };\r\n    WuQuant._alpha = 3;\r\n    WuQuant._red = 2;\r\n    WuQuant._green = 1;\r\n    WuQuant._blue = 0;\r\n    return WuQuant;\r\n}(paletteQuantizer.AbstractPaletteQuantizer));\r\nexports.WuQuant = WuQuant;\r\n\n});\n\nunwrapExports(wuQuant);\nvar wuQuant_1 = wuQuant.WuColorCube;\nvar wuQuant_2 = wuQuant.WuQuant;\n\nvar palette$2 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\nexports.AbstractPaletteQuantizer = paletteQuantizer.AbstractPaletteQuantizer;\r\n\r\nexports.NeuQuant = neuquant.NeuQuant;\r\n\r\nexports.NeuQuantFloat = neuquantFloat.NeuQuantFloat;\r\n\r\nexports.RGBQuant = rgbquant.RGBQuant;\r\n\r\nexports.ColorHistogram = colorHistogram.ColorHistogram;\r\n\r\nexports.WuQuant = wuQuant.WuQuant;\r\nexports.WuColorCube = wuQuant.WuColorCube;\r\n\n});\n\nunwrapExports(palette$2);\nvar palette_1$1 = palette$2.AbstractPaletteQuantizer;\nvar palette_2$1 = palette$2.NeuQuant;\nvar palette_3 = palette$2.NeuQuantFloat;\nvar palette_4 = palette$2.RGBQuant;\nvar palette_5 = palette$2.ColorHistogram;\nvar palette_6 = palette$2.WuQuant;\nvar palette_7 = palette$2.WuColorCube;\n\nvar imageQuantizer = createCommonjsModule(function (module, exports) {\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\nvar AbstractImageQuantizer = /** @class */ (function () {\r\n    function AbstractImageQuantizer() {\r\n    }\r\n    AbstractImageQuantizer.prototype.quantizeSync = function (pointContainer, palette) {\r\n        try {\r\n            for (var _a = __values(this.quantize(pointContainer, palette)), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var value = _b.value;\r\n                if (value.pointContainer) {\r\n                    return value.pointContainer;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        throw new Error(\'unreachable\');\r\n        var e_1, _c;\r\n    };\r\n    return AbstractImageQuantizer;\r\n}());\r\nexports.AbstractImageQuantizer = AbstractImageQuantizer;\r\n\n});\n\nunwrapExports(imageQuantizer);\nvar imageQuantizer_1 = imageQuantizer.AbstractImageQuantizer;\n\nvar nearestColor = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * nearestColor.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nvar NearestColor = /** @class */ (function (_super) {\r\n    __extends(NearestColor, _super);\r\n    function NearestColor(colorDistanceCalculator) {\r\n        var _this = _super.call(this) || this;\r\n        _this._distance = colorDistanceCalculator;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Mutates pointContainer\r\n     */\r\n    NearestColor.prototype.quantize = function (pointContainer, palette) {\r\n        var pointArray, width, height, tracker, y, x, idx, point;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    pointArray = pointContainer.getPointArray();\r\n                    width = pointContainer.getWidth();\r\n                    height = pointContainer.getHeight();\r\n                    tracker = new progressTracker.ProgressTracker(height, 99);\r\n                    y = 0;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(y < height)) return [3 /*break*/, 5];\r\n                    if (!tracker.shouldNotify(y)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, {\r\n                            progress: tracker.progress,\r\n                        }];\r\n                case 2:\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3:\r\n                    for (x = 0, idx = y * width; x < width; x++, idx++) {\r\n                        point = pointArray[idx];\r\n                        // Reduced pixel\r\n                        point.from(palette.getNearestColor(this._distance, point));\r\n                    }\r\n                    _a.label = 4;\r\n                case 4:\r\n                    y++;\r\n                    return [3 /*break*/, 1];\r\n                case 5: return [4 /*yield*/, {\r\n                        pointContainer: pointContainer,\r\n                        progress: 100,\r\n                    }];\r\n                case 6:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return NearestColor;\r\n}(imageQuantizer.AbstractImageQuantizer));\r\nexports.NearestColor = NearestColor;\r\n\n});\n\nunwrapExports(nearestColor);\nvar nearestColor_1 = nearestColor.NearestColor;\n\nvar array = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n// TODO: is it the best name for this enum "kernel"?\r\nvar ErrorDiffusionArrayKernel;\r\n(function (ErrorDiffusionArrayKernel) {\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["FloydSteinberg"] = 0] = "FloydSteinberg";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Stucki"] = 2] = "Stucki";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Atkinson"] = 3] = "Atkinson";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Jarvis"] = 4] = "Jarvis";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Burkes"] = 5] = "Burkes";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Sierra"] = 6] = "Sierra";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["TwoSierra"] = 7] = "TwoSierra";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["SierraLite"] = 8] = "SierraLite";\r\n})(ErrorDiffusionArrayKernel = exports.ErrorDiffusionArrayKernel || (exports.ErrorDiffusionArrayKernel = {}));\r\n// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\r\nvar ErrorDiffusionArray = /** @class */ (function (_super) {\r\n    __extends(ErrorDiffusionArray, _super);\r\n    function ErrorDiffusionArray(colorDistanceCalculator, kernel, serpentine, minimumColorDistanceToDither, calculateErrorLikeGIMP) {\r\n        if (serpentine === void 0) { serpentine = true; }\r\n        if (minimumColorDistanceToDither === void 0) { minimumColorDistanceToDither = 0; }\r\n        if (calculateErrorLikeGIMP === void 0) { calculateErrorLikeGIMP = false; }\r\n        var _this = _super.call(this) || this;\r\n        _this._setKernel(kernel);\r\n        _this._distance = colorDistanceCalculator;\r\n        _this._minColorDistance = minimumColorDistanceToDither;\r\n        _this._serpentine = serpentine;\r\n        _this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\r\n        return _this;\r\n    }\r\n    /**\r\n     * adapted from http://jsbin.com/iXofIji/2/edit by PAEz\r\n     * fixed version. it doesn\'t use image pixels as error storage, also it doesn\'t have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\r\n     * Mutates pointContainer\r\n     */\r\n    ErrorDiffusionArray.prototype.quantize = function (pointContainer, palette) {\r\n        var pointArray, originalPoint, width, height, errorLines, dir, maxErrorLines, _a, _b, kernel, kernelErrorLines, i, tracker, y, lni, xStart, xEnd, errorLine, x, idx, point$$1, error, correctedPoint, palettePoint, dist, er, eg, eb, ea, dStart, dEnd, i, x1, y1, d, e, e_1, _c;\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    pointArray = pointContainer.getPointArray();\r\n                    originalPoint = new point.Point();\r\n                    width = pointContainer.getWidth();\r\n                    height = pointContainer.getHeight();\r\n                    errorLines = [];\r\n                    dir = 1;\r\n                    maxErrorLines = 1;\r\n                    try {\r\n                        // initial error lines (number is taken from dithering kernel)\r\n                        for (_a = __values(this._kernel), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                            kernel = _b.value;\r\n                            kernelErrorLines = kernel[2] + 1;\r\n                            if (maxErrorLines < kernelErrorLines)\r\n                                maxErrorLines = kernelErrorLines;\r\n                        }\r\n                    }\r\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n                        }\r\n                        finally { if (e_1) throw e_1.error; }\r\n                    }\r\n                    for (i = 0; i < maxErrorLines; i++) {\r\n                        this._fillErrorLine(errorLines[i] = [], width);\r\n                    }\r\n                    tracker = new progressTracker.ProgressTracker(height, 99);\r\n                    y = 0;\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!(y < height)) return [3 /*break*/, 5];\r\n                    if (!tracker.shouldNotify(y)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, {\r\n                            progress: tracker.progress,\r\n                        }];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    // always serpentine\r\n                    if (this._serpentine)\r\n                        dir = dir * -1;\r\n                    lni = y * width;\r\n                    xStart = dir === 1 ? 0 : width - 1;\r\n                    xEnd = dir === 1 ? width : -1;\r\n                    // cyclic shift with erasing\r\n                    this._fillErrorLine(errorLines[0], width);\r\n                    // TODO: why it is needed to cast types here?\r\n                    errorLines.push(errorLines.shift());\r\n                    errorLine = errorLines[0];\r\n                    for (x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {\r\n                        point$$1 = pointArray[idx];\r\n                        error = errorLine[x];\r\n                        originalPoint.from(point$$1);\r\n                        correctedPoint = point.Point.createByRGBA(arithmetic.inRange0to255Rounded(point$$1.r + error[0]), arithmetic.inRange0to255Rounded(point$$1.g + error[1]), arithmetic.inRange0to255Rounded(point$$1.b + error[2]), arithmetic.inRange0to255Rounded(point$$1.a + error[3]));\r\n                        palettePoint = palette.getNearestColor(this._distance, correctedPoint);\r\n                        point$$1.from(palettePoint);\r\n                        // dithering strength\r\n                        if (this._minColorDistance) {\r\n                            dist = this._distance.calculateNormalized(point$$1, palettePoint);\r\n                            if (dist < this._minColorDistance)\r\n                                continue;\r\n                        }\r\n                        er = void 0;\r\n                        eg = void 0;\r\n                        eb = void 0;\r\n                        ea = void 0;\r\n                        if (this._calculateErrorLikeGIMP) {\r\n                            er = correctedPoint.r - palettePoint.r;\r\n                            eg = correctedPoint.g - palettePoint.g;\r\n                            eb = correctedPoint.b - palettePoint.b;\r\n                            ea = correctedPoint.a - palettePoint.a;\r\n                        }\r\n                        else {\r\n                            er = originalPoint.r - palettePoint.r;\r\n                            eg = originalPoint.g - palettePoint.g;\r\n                            eb = originalPoint.b - palettePoint.b;\r\n                            ea = originalPoint.a - palettePoint.a;\r\n                        }\r\n                        dStart = dir === 1 ? 0 : this._kernel.length - 1;\r\n                        dEnd = dir === 1 ? this._kernel.length : -1;\r\n                        for (i = dStart; i !== dEnd; i += dir) {\r\n                            x1 = this._kernel[i][1] * dir;\r\n                            y1 = this._kernel[i][2];\r\n                            if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\r\n                                d = this._kernel[i][0];\r\n                                e = errorLines[y1][x1 + x];\r\n                                e[0] = e[0] + er * d;\r\n                                e[1] = e[1] + eg * d;\r\n                                e[2] = e[2] + eb * d;\r\n                                e[3] = e[3] + ea * d;\r\n                            }\r\n                        }\r\n                    }\r\n                    _d.label = 4;\r\n                case 4:\r\n                    y++;\r\n                    return [3 /*break*/, 1];\r\n                case 5: return [4 /*yield*/, {\r\n                        pointContainer: pointContainer,\r\n                        progress: 100,\r\n                    }];\r\n                case 6:\r\n                    _d.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    ErrorDiffusionArray.prototype._fillErrorLine = function (errorLine, width) {\r\n        // shrink\r\n        if (errorLine.length > width) {\r\n            errorLine.length = width;\r\n        }\r\n        // reuse existing arrays\r\n        var l = errorLine.length;\r\n        for (var i = 0; i < l; i++) {\r\n            var error = errorLine[i];\r\n            error[0] = error[1] = error[2] = error[3] = 0;\r\n        }\r\n        // create missing arrays\r\n        for (var i = l; i < width; i++) {\r\n            errorLine[i] = [0.0, 0.0, 0.0, 0.0];\r\n        }\r\n    };\r\n    ErrorDiffusionArray.prototype._setKernel = function (kernel) {\r\n        switch (kernel) {\r\n            case ErrorDiffusionArrayKernel.FloydSteinberg:\r\n                this._kernel = [\r\n                    [7 / 16, 1, 0],\r\n                    [3 / 16, -1, 1],\r\n                    [5 / 16, 0, 1],\r\n                    [1 / 16, 1, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\r\n                this._kernel = [\r\n                    [3 / 8, 1, 0],\r\n                    [3 / 8, 0, 1],\r\n                    [2 / 8, 1, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Stucki:\r\n                this._kernel = [\r\n                    [8 / 42, 1, 0],\r\n                    [4 / 42, 2, 0],\r\n                    [2 / 42, -2, 1],\r\n                    [4 / 42, -1, 1],\r\n                    [8 / 42, 0, 1],\r\n                    [4 / 42, 1, 1],\r\n                    [2 / 42, 2, 1],\r\n                    [1 / 42, -2, 2],\r\n                    [2 / 42, -1, 2],\r\n                    [4 / 42, 0, 2],\r\n                    [2 / 42, 1, 2],\r\n                    [1 / 42, 2, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Atkinson:\r\n                this._kernel = [\r\n                    [1 / 8, 1, 0],\r\n                    [1 / 8, 2, 0],\r\n                    [1 / 8, -1, 1],\r\n                    [1 / 8, 0, 1],\r\n                    [1 / 8, 1, 1],\r\n                    [1 / 8, 0, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Jarvis:\r\n                this._kernel = [\r\n                    [7 / 48, 1, 0],\r\n                    [5 / 48, 2, 0],\r\n                    [3 / 48, -2, 1],\r\n                    [5 / 48, -1, 1],\r\n                    [7 / 48, 0, 1],\r\n                    [5 / 48, 1, 1],\r\n                    [3 / 48, 2, 1],\r\n                    [1 / 48, -2, 2],\r\n                    [3 / 48, -1, 2],\r\n                    [5 / 48, 0, 2],\r\n                    [3 / 48, 1, 2],\r\n                    [1 / 48, 2, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Burkes:\r\n                this._kernel = [\r\n                    [8 / 32, 1, 0],\r\n                    [4 / 32, 2, 0],\r\n                    [2 / 32, -2, 1],\r\n                    [4 / 32, -1, 1],\r\n                    [8 / 32, 0, 1],\r\n                    [4 / 32, 1, 1],\r\n                    [2 / 32, 2, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Sierra:\r\n                this._kernel = [\r\n                    [5 / 32, 1, 0],\r\n                    [3 / 32, 2, 0],\r\n                    [2 / 32, -2, 1],\r\n                    [4 / 32, -1, 1],\r\n                    [5 / 32, 0, 1],\r\n                    [4 / 32, 1, 1],\r\n                    [2 / 32, 2, 1],\r\n                    [2 / 32, -1, 2],\r\n                    [3 / 32, 0, 2],\r\n                    [2 / 32, 1, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.TwoSierra:\r\n                this._kernel = [\r\n                    [4 / 16, 1, 0],\r\n                    [3 / 16, 2, 0],\r\n                    [1 / 16, -2, 1],\r\n                    [2 / 16, -1, 1],\r\n                    [3 / 16, 0, 1],\r\n                    [2 / 16, 1, 1],\r\n                    [1 / 16, 2, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.SierraLite:\r\n                this._kernel = [\r\n                    [2 / 4, 1, 0],\r\n                    [1 / 4, -1, 1],\r\n                    [1 / 4, 0, 1],\r\n                ];\r\n                break;\r\n            default:\r\n                throw new Error(\'ErrorDiffusionArray: unknown kernel = \' + kernel);\r\n        }\r\n    };\r\n    return ErrorDiffusionArray;\r\n}(imageQuantizer.AbstractImageQuantizer));\r\nexports.ErrorDiffusionArray = ErrorDiffusionArray;\r\n\n});\n\nunwrapExports(array);\nvar array_1 = array.ErrorDiffusionArrayKernel;\nvar array_2 = array.ErrorDiffusionArray;\n\nvar hilbertCurve_1 = createCommonjsModule(function (module, exports) {\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction["NONE"] = 0] = "NONE";\r\n    Direction[Direction["UP"] = 1] = "UP";\r\n    Direction[Direction["LEFT"] = 2] = "LEFT";\r\n    Direction[Direction["RIGHT"] = 3] = "RIGHT";\r\n    Direction[Direction["DOWN"] = 4] = "DOWN";\r\n})(Direction || (Direction = {}));\r\nfunction hilbertCurve(width, height, callback) {\r\n    var maxBound, level, tracker, data;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                maxBound = Math.max(width, height);\r\n                level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\r\n                tracker = new progressTracker.ProgressTracker(width * height, 99);\r\n                data = {\r\n                    width: width,\r\n                    height: height,\r\n                    level: level,\r\n                    callback: callback,\r\n                    tracker: tracker,\r\n                    index: 0,\r\n                    x: 0,\r\n                    y: 0,\r\n                };\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.UP))];\r\n            case 1:\r\n                _a.sent();\r\n                visit(data, Direction.NONE);\r\n                return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nexports.hilbertCurve = hilbertCurve;\r\nfunction walkHilbert(data, direction) {\r\n    var _a;\r\n    return __generator(this, function (_b) {\r\n        switch (_b.label) {\r\n            case 0:\r\n                if (data.level < 1)\r\n                    return [2 /*return*/];\r\n                if (!data.tracker.shouldNotify(data.index)) return [3 /*break*/, 2];\r\n                return [4 /*yield*/, { progress: data.tracker.progress }];\r\n            case 1:\r\n                _b.sent();\r\n                _b.label = 2;\r\n            case 2:\r\n                data.level--;\r\n                _a = direction;\r\n                switch (_a) {\r\n                    case Direction.LEFT: return [3 /*break*/, 3];\r\n                    case Direction.RIGHT: return [3 /*break*/, 8];\r\n                    case Direction.UP: return [3 /*break*/, 13];\r\n                    case Direction.DOWN: return [3 /*break*/, 18];\r\n                }\r\n                return [3 /*break*/, 23];\r\n            case 3: return [5 /*yield**/, __values(walkHilbert(data, Direction.UP))];\r\n            case 4:\r\n                _b.sent();\r\n                visit(data, Direction.RIGHT);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.LEFT))];\r\n            case 5:\r\n                _b.sent();\r\n                visit(data, Direction.DOWN);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.LEFT))];\r\n            case 6:\r\n                _b.sent();\r\n                visit(data, Direction.LEFT);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.DOWN))];\r\n            case 7:\r\n                _b.sent();\r\n                return [3 /*break*/, 24];\r\n            case 8: return [5 /*yield**/, __values(walkHilbert(data, Direction.DOWN))];\r\n            case 9:\r\n                _b.sent();\r\n                visit(data, Direction.LEFT);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.RIGHT))];\r\n            case 10:\r\n                _b.sent();\r\n                visit(data, Direction.UP);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.RIGHT))];\r\n            case 11:\r\n                _b.sent();\r\n                visit(data, Direction.RIGHT);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.UP))];\r\n            case 12:\r\n                _b.sent();\r\n                return [3 /*break*/, 24];\r\n            case 13: return [5 /*yield**/, __values(walkHilbert(data, Direction.LEFT))];\r\n            case 14:\r\n                _b.sent();\r\n                visit(data, Direction.DOWN);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.UP))];\r\n            case 15:\r\n                _b.sent();\r\n                visit(data, Direction.RIGHT);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.UP))];\r\n            case 16:\r\n                _b.sent();\r\n                visit(data, Direction.UP);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.RIGHT))];\r\n            case 17:\r\n                _b.sent();\r\n                return [3 /*break*/, 24];\r\n            case 18: return [5 /*yield**/, __values(walkHilbert(data, Direction.RIGHT))];\r\n            case 19:\r\n                _b.sent();\r\n                visit(data, Direction.UP);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.DOWN))];\r\n            case 20:\r\n                _b.sent();\r\n                visit(data, Direction.LEFT);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.DOWN))];\r\n            case 21:\r\n                _b.sent();\r\n                visit(data, Direction.DOWN);\r\n                return [5 /*yield**/, __values(walkHilbert(data, Direction.LEFT))];\r\n            case 22:\r\n                _b.sent();\r\n                return [3 /*break*/, 24];\r\n            case 23: return [3 /*break*/, 24];\r\n            case 24:\r\n                data.level++;\r\n                return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nfunction visit(data, direction) {\r\n    if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {\r\n        data.callback(data.x, data.y);\r\n        data.index++;\r\n    }\r\n    switch (direction) {\r\n        case Direction.LEFT:\r\n            data.x--;\r\n            break;\r\n        case Direction.RIGHT:\r\n            data.x++;\r\n            break;\r\n        case Direction.UP:\r\n            data.y--;\r\n            break;\r\n        case Direction.DOWN:\r\n            data.y++;\r\n            break;\r\n    }\r\n}\r\n\n});\n\nunwrapExports(hilbertCurve_1);\nvar hilbertCurve_2 = hilbertCurve_1.hilbertCurve;\n\nvar riemersma = createCommonjsModule(function (module, exports) {\nvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * MIT License\r\n *\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the "Software"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n *\r\n * riemersma.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\nvar ErrorDiffusionRiemersma = /** @class */ (function (_super) {\r\n    __extends(ErrorDiffusionRiemersma, _super);\r\n    function ErrorDiffusionRiemersma(colorDistanceCalculator, errorQueueSize, errorPropagation) {\r\n        if (errorQueueSize === void 0) { errorQueueSize = 16; }\r\n        if (errorPropagation === void 0) { errorPropagation = 1; }\r\n        var _this = _super.call(this) || this;\r\n        _this._distance = colorDistanceCalculator;\r\n        _this._errorQueueSize = errorQueueSize;\r\n        _this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Mutates pointContainer\r\n     */\r\n    ErrorDiffusionRiemersma.prototype.quantize = function (pointContainer, palette) {\r\n        var _this = this;\r\n        var pointArray, width, height, errorQueue, head, i;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    pointArray = pointContainer.getPointArray();\r\n                    width = pointContainer.getWidth();\r\n                    height = pointContainer.getHeight();\r\n                    errorQueue = [];\r\n                    head = 0;\r\n                    for (i = 0; i < this._errorQueueSize; i++) {\r\n                        errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };\r\n                    }\r\n                    return [5 /*yield**/, __values(hilbertCurve_1.hilbertCurve(width, height, function (x, y) {\r\n                            var p = pointArray[x + y * width];\r\n                            var r = p.r;\r\n                            var g = p.g;\r\n                            var b = p.b;\r\n                            var a = p.a;\r\n                            for (var i = 0; i < _this._errorQueueSize; i++) {\r\n                                var weight = _this._weights[i];\r\n                                var e = errorQueue[(i + head) % _this._errorQueueSize];\r\n                                r += e.r * weight;\r\n                                g += e.g * weight;\r\n                                b += e.b * weight;\r\n                                a += e.a * weight;\r\n                            }\r\n                            var correctedPoint = point.Point.createByRGBA(arithmetic.inRange0to255Rounded(r), arithmetic.inRange0to255Rounded(g), arithmetic.inRange0to255Rounded(b), arithmetic.inRange0to255Rounded(a));\r\n                            var quantizedPoint = palette.getNearestColor(_this._distance, correctedPoint);\r\n                            // update head and calculate tail\r\n                            head = (head + 1) % _this._errorQueueSize;\r\n                            var tail = (head + _this._errorQueueSize - 1) % _this._errorQueueSize;\r\n                            // update error with new value\r\n                            errorQueue[tail].r = p.r - quantizedPoint.r;\r\n                            errorQueue[tail].g = p.g - quantizedPoint.g;\r\n                            errorQueue[tail].b = p.b - quantizedPoint.b;\r\n                            errorQueue[tail].a = p.a - quantizedPoint.a;\r\n                            // update point\r\n                            p.from(quantizedPoint);\r\n                        }))];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, {\r\n                            pointContainer: pointContainer,\r\n                            progress: 100,\r\n                        }];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    ErrorDiffusionRiemersma._createWeights = function (errorPropagation, errorQueueSize) {\r\n        var weights = [];\r\n        var multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));\r\n        for (var i = 0, next = 1; i < errorQueueSize; i++) {\r\n            weights[i] = (((next + 0.5) | 0) / errorQueueSize) * errorPropagation;\r\n            next *= multiplier;\r\n        }\r\n        return weights;\r\n    };\r\n    return ErrorDiffusionRiemersma;\r\n}(imageQuantizer.AbstractImageQuantizer));\r\nexports.ErrorDiffusionRiemersma = ErrorDiffusionRiemersma;\r\n\n});\n\nunwrapExports(riemersma);\nvar riemersma_1 = riemersma.ErrorDiffusionRiemersma;\n\nvar image = createCommonjsModule(function (module, exports) {\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n\r\nexports.AbstractImageQuantizer = imageQuantizer.AbstractImageQuantizer;\r\n\r\nexports.NearestColor = nearestColor.NearestColor;\r\n\r\nexports.ErrorDiffusionArray = array.ErrorDiffusionArray;\r\nexports.ErrorDiffusionArrayKernel = array.ErrorDiffusionArrayKernel;\r\n\r\nexports.ErrorDiffusionRiemersma = riemersma.ErrorDiffusionRiemersma;\r\n\n});\n\nunwrapExports(image);\nvar image_1 = image.AbstractImageQuantizer;\nvar image_2 = image.NearestColor;\nvar image_3 = image.ErrorDiffusionArray;\nvar image_4 = image.ErrorDiffusionArrayKernel;\nvar image_5 = image.ErrorDiffusionRiemersma;\n\nvar ssim_1 = createCommonjsModule(function (module, exports) {\nvar __values = (commonjsGlobal && commonjsGlobal.__values) || function (o) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n\r\n// based on https://github.com/rhys-e/structural-similarity\r\n// http://en.wikipedia.org/wiki/Structural_similarity\r\nvar K1 = 0.01; // tslint:disable-line:naming-convention\r\nvar K2 = 0.03; // tslint:disable-line:naming-convention\r\nfunction ssim(image1, image2) {\r\n    if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\r\n        throw new Error(\'Images have different sizes!\');\r\n    }\r\n    var bitsPerComponent = 8;\r\n    var L = (1 << bitsPerComponent) - 1; // tslint:disable-line:naming-convention\r\n    var c1 = Math.pow((K1 * L), 2);\r\n    var c2 = Math.pow((K2 * L), 2);\r\n    var numWindows = 0;\r\n    var mssim = 0.0;\r\n    // calculate ssim for each window\r\n    iterate(image1, image2, function (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {\r\n        // calculate variance and covariance\r\n        var sigxy = 0.0;\r\n        var sigsqx = 0.0;\r\n        var sigsqy = 0.0;\r\n        for (var i = 0; i < lumaValues1.length; i++) {\r\n            sigsqx += Math.pow((lumaValues1[i] - averageLumaValue1), 2);\r\n            sigsqy += Math.pow((lumaValues2[i] - averageLumaValue2), 2);\r\n            sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);\r\n        }\r\n        var numPixelsInWin = lumaValues1.length - 1;\r\n        sigsqx /= numPixelsInWin;\r\n        sigsqy /= numPixelsInWin;\r\n        sigxy /= numPixelsInWin;\r\n        // perform ssim calculation on window\r\n        var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\r\n        var denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2);\r\n        var ssim = numerator / denominator;\r\n        mssim += ssim;\r\n        numWindows++;\r\n    });\r\n    return mssim / numWindows;\r\n}\r\nexports.ssim = ssim;\r\nfunction iterate(image1, image2, callback) {\r\n    var windowSize = 8;\r\n    var width = image1.getWidth();\r\n    var height = image1.getHeight();\r\n    for (var y = 0; y < height; y += windowSize) {\r\n        for (var x = 0; x < width; x += windowSize) {\r\n            // avoid out-of-width/height\r\n            var windowWidth = Math.min(windowSize, width - x);\r\n            var windowHeight = Math.min(windowSize, height - y);\r\n            var lumaValues1 = calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight);\r\n            var lumaValues2 = calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight);\r\n            var averageLuma1 = calculateAverageLuma(lumaValues1);\r\n            var averageLuma2 = calculateAverageLuma(lumaValues2);\r\n            callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\r\n        }\r\n    }\r\n}\r\nfunction calculateLumaValuesForWindow(image, x, y, width, height) {\r\n    var pointArray = image.getPointArray();\r\n    var lumaValues = [];\r\n    var counter = 0;\r\n    for (var j = y; j < y + height; j++) {\r\n        var offset = j * image.getWidth();\r\n        for (var i = x; i < x + width; i++) {\r\n            var point = pointArray[offset + i];\r\n            lumaValues[counter] = point.r * bt709.Y.RED + point.g * bt709.Y.GREEN + point.b * bt709.Y.BLUE;\r\n            counter++;\r\n        }\r\n    }\r\n    return lumaValues;\r\n}\r\nfunction calculateAverageLuma(lumaValues) {\r\n    var sumLuma = 0.0;\r\n    try {\r\n        for (var lumaValues_1 = __values(lumaValues), lumaValues_1_1 = lumaValues_1.next(); !lumaValues_1_1.done; lumaValues_1_1 = lumaValues_1.next()) {\r\n            var luma = lumaValues_1_1.value;\r\n            sumLuma += luma;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (lumaValues_1_1 && !lumaValues_1_1.done && (_a = lumaValues_1.return)) _a.call(lumaValues_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return sumLuma / lumaValues.length;\r\n    var e_1, _a;\r\n}\r\n\n});\n\nunwrapExports(ssim_1);\nvar ssim_2 = ssim_1.ssim;\n\nvar quality = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\nexports.ssim = ssim_1.ssim;\r\n\n});\n\nunwrapExports(quality);\nvar quality_1 = quality.ssim;\n\nvar _global = createCommonjsModule(function (module) {\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != \'undefined\' && window.Math == Math\n  ? window : typeof self != \'undefined\' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function(\'return this\')();\nif (typeof __g == \'number\') __g = global; // eslint-disable-line no-undef\n});\n\nvar _core = createCommonjsModule(function (module) {\nvar core = module.exports = { version: \'2.5.3\' };\nif (typeof __e == \'number\') __e = core; // eslint-disable-line no-undef\n});\nvar _core_1 = _core.version;\n\nvar _isObject = function (it) {\n  return typeof it === \'object\' ? it !== null : typeof it === \'function\';\n};\n\nvar _anObject = function (it) {\n  if (!_isObject(it)) throw TypeError(it + \' is not an object!\');\n  return it;\n};\n\nvar _fails = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n// Thank\'s IE8 for his funny defineProperty\nvar _descriptors = !_fails(function () {\n  return Object.defineProperty({}, \'a\', { get: function () { return 7; } }).a != 7;\n});\n\nvar document$1 = _global.document;\n// typeof document.createElement is \'object\' in old IE\nvar is = _isObject(document$1) && _isObject(document$1.createElement);\nvar _domCreate = function (it) {\n  return is ? document$1.createElement(it) : {};\n};\n\nvar _ie8DomDefine = !_descriptors && !_fails(function () {\n  return Object.defineProperty(_domCreate(\'div\'), \'a\', { get: function () { return 7; } }).a != 7;\n});\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n\n// instead of the ES6 spec version, we didn\'t implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nvar _toPrimitive = function (it, S) {\n  if (!_isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == \'function\' && !_isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == \'function\' && !_isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == \'function\' && !_isObject(val = fn.call(it))) return val;\n  throw TypeError("Can\'t convert object to primitive value");\n};\n\nvar dP = Object.defineProperty;\n\nvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  _anObject(O);\n  P = _toPrimitive(P, true);\n  _anObject(Attributes);\n  if (_ie8DomDefine) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if (\'get\' in Attributes || \'set\' in Attributes) throw TypeError(\'Accessors not supported!\');\n  if (\'value\' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar _objectDp = {\n\tf: f\n};\n\nvar _propertyDesc = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar _hide = _descriptors ? function (object, key, value) {\n  return _objectDp.f(object, key, _propertyDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar hasOwnProperty = {}.hasOwnProperty;\nvar _has = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\nvar id = 0;\nvar px = Math.random();\nvar _uid = function (key) {\n  return \'Symbol(\'.concat(key === undefined ? \'\' : key, \')_\', (++id + px).toString(36));\n};\n\nvar _redefine = createCommonjsModule(function (module) {\nvar SRC = _uid(\'src\');\nvar TO_STRING = \'toString\';\nvar $toString = Function[TO_STRING];\nvar TPL = (\'\' + $toString).split(TO_STRING);\n\n_core.inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == \'function\';\n  if (isFunction) _has(val, \'name\') || _hide(val, \'name\', key);\n  if (O[key] === val) return;\n  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? \'\' + O[key] : TPL.join(String(key)));\n  if (O === _global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    _hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    _hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == \'function\' && this[SRC] || $toString.call(this);\n});\n});\n\nvar _aFunction = function (it) {\n  if (typeof it != \'function\') throw TypeError(it + \' is not a function!\');\n  return it;\n};\n\n// optional / simple context binding\n\nvar _ctx = function (fn, that, length) {\n  _aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar PROTOTYPE = \'prototype\';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == \'function\' ? _ctx(Function.call, out) : out;\n    // extend global\n    if (target) _redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) _hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\n_global.core = _core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nvar _export = $export;\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nvar _invoke = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\nvar document$2 = _global.document;\nvar _html = document$2 && document$2.documentElement;\n\nvar toString = {}.toString;\n\nvar _cof = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\nvar process = _global.process;\nvar setTask = _global.setImmediate;\nvar clearTask = _global.clearImmediate;\nvar MessageChannel = _global.MessageChannel;\nvar Dispatch = _global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = \'onreadystatechange\';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      _invoke(typeof fn == \'function\' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (_cof(process) == \'process\') {\n    defer = function (id) {\n      process.nextTick(_ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(_ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = _ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it\'s sync & typeof its postMessage is \'object\'\n  } else if (_global.addEventListener && typeof postMessage == \'function\' && !_global.importScripts) {\n    defer = function (id) {\n      _global.postMessage(id + \'\', \'*\');\n    };\n    _global.addEventListener(\'message\', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in _domCreate(\'script\')) {\n    defer = function (id) {\n      _html.appendChild(_domCreate(\'script\'))[ONREADYSTATECHANGE] = function () {\n        _html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(_ctx(run, id, 1), 0);\n    };\n  }\n}\nvar _task = {\n  set: setTask,\n  clear: clearTask\n};\n\n_export(_export.G + _export.B, {\n  setImmediate: _task.set,\n  clearImmediate: _task.clear\n});\n\nvar setImmediate = _core.setImmediate;\n\nvar basicAPI = createCommonjsModule(function (module, exports) {\nvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * helper.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\nvar palette = palette$2;\r\nfunction buildPaletteSync(images, _a) {\r\n    var _b = _a === void 0 ? {} : _a, colorDistanceFormula = _b.colorDistanceFormula, paletteQuantization = _b.paletteQuantization, colors = _b.colors;\r\n    var distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n    var paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\r\n    images.forEach(function (image$$1) { return paletteQuantizer.sample(image$$1); });\r\n    return paletteQuantizer.quantizeSync();\r\n}\r\nexports.buildPaletteSync = buildPaletteSync;\r\nfunction buildPalette(images, _a) {\r\n    var _b = _a === void 0 ? {} : _a, colorDistanceFormula = _b.colorDistanceFormula, paletteQuantization = _b.paletteQuantization, colors = _b.colors, onProgress = _b.onProgress;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_c) {\r\n            return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                    var distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n                    var paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\r\n                    images.forEach(function (image$$1) { return paletteQuantizer.sample(image$$1); });\r\n                    var palette;\r\n                    var timerId;\r\n                    var iterator = paletteQuantizer.quantize();\r\n                    var next = function () {\r\n                        try {\r\n                            var result = iterator.next();\r\n                            if (result.done) {\r\n                                resolve(palette);\r\n                            }\r\n                            else {\r\n                                if (result.value.palette)\r\n                                    palette = result.value.palette;\r\n                                if (onProgress)\r\n                                    onProgress(result.value.progress);\r\n                                timerId = setImmediate(next);\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            clearTimeout(timerId);\r\n                            reject(error);\r\n                        }\r\n                    };\r\n                    timerId = setImmediate(next);\r\n                })];\r\n        });\r\n    });\r\n}\r\nexports.buildPalette = buildPalette;\r\nfunction applyPaletteSync(image$$1, palette, _a) {\r\n    var _b = _a === void 0 ? {} : _a, colorDistanceFormula = _b.colorDistanceFormula, imageQuantization = _b.imageQuantization;\r\n    var distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n    var imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\r\n    return imageQuantizer.quantizeSync(image$$1, palette);\r\n}\r\nexports.applyPaletteSync = applyPaletteSync;\r\nfunction applyPalette(image$$1, palette, _a) {\r\n    var _b = _a === void 0 ? {} : _a, colorDistanceFormula = _b.colorDistanceFormula, imageQuantization = _b.imageQuantization, onProgress = _b.onProgress;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_c) {\r\n            return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                    var distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n                    var imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\r\n                    var outPointContainer;\r\n                    var timerId;\r\n                    var iterator = imageQuantizer.quantize(image$$1, palette);\r\n                    var next = function () {\r\n                        try {\r\n                            var result = iterator.next();\r\n                            if (result.done) {\r\n                                resolve(outPointContainer);\r\n                            }\r\n                            else {\r\n                                if (result.value.pointContainer)\r\n                                    outPointContainer = result.value.pointContainer;\r\n                                if (onProgress)\r\n                                    onProgress(result.value.progress);\r\n                                timerId = setImmediate(next);\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            clearTimeout(timerId);\r\n                            reject(error);\r\n                        }\r\n                    };\r\n                    timerId = setImmediate(next);\r\n                })];\r\n        });\r\n    });\r\n}\r\nexports.applyPalette = applyPalette;\r\nfunction colorDistanceFormulaToColorDistance(colorDistanceFormula) {\r\n    if (colorDistanceFormula === void 0) { colorDistanceFormula = \'euclidean-bt709\'; }\r\n    switch (colorDistanceFormula) {\r\n        case \'cie94-graphic-arts\': return new distance.CIE94GraphicArts();\r\n        case \'cie94-textiles\': return new distance.CIE94Textiles();\r\n        case \'ciede2000\': return new distance.CIEDE2000();\r\n        case \'color-metric\': return new distance.CMetric();\r\n        case \'euclidean\': return new distance.Euclidean();\r\n        case \'euclidean-bt709\': return new distance.EuclideanBT709();\r\n        case \'euclidean-bt709-noalpha\': return new distance.EuclideanBT709NoAlpha();\r\n        case \'manhattan\': return new distance.Manhattan();\r\n        case \'manhattan-bt709\': return new distance.ManhattanBT709();\r\n        case \'manhattan-nommyde\': return new distance.ManhattanNommyde();\r\n        case \'pngquant\': return new distance.PNGQuant();\r\n        default: throw new Error("Unknown colorDistanceFormula " + colorDistanceFormula);\r\n    }\r\n}\r\nfunction imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization) {\r\n    if (imageQuantization === void 0) { imageQuantization = \'floyd-steinberg\'; }\r\n    switch (imageQuantization) {\r\n        case \'nearest\': return new image.NearestColor(distanceCalculator);\r\n        case \'riemersma\': return new image.ErrorDiffusionRiemersma(distanceCalculator);\r\n        case \'floyd-steinberg\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.FloydSteinberg);\r\n        case \'false-floyd-steinberg\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.FalseFloydSteinberg);\r\n        case \'stucki\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Stucki);\r\n        case \'atkinson\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Atkinson);\r\n        case \'jarvis\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Jarvis);\r\n        case \'burkes\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Burkes);\r\n        case \'sierra\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Sierra);\r\n        case \'two-sierra\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.TwoSierra);\r\n        case \'sierra-lite\': return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.SierraLite);\r\n        default: throw new Error("Unknown imageQuantization " + imageQuantization);\r\n    }\r\n}\r\nfunction paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors) {\r\n    if (paletteQuantization === void 0) { paletteQuantization = \'wuquant\'; }\r\n    if (colors === void 0) { colors = 256; }\r\n    switch (paletteQuantization) {\r\n        case \'neuquant\': return new palette.NeuQuant(distanceCalculator, colors);\r\n        case \'rgbquant\': return new palette.RGBQuant(distanceCalculator, colors);\r\n        case \'wuquant\': return new palette.WuQuant(distanceCalculator, colors);\r\n        case \'neuquant-float\': return new palette.NeuQuantFloat(distanceCalculator, colors);\r\n        default: throw new Error("Unknown paletteQuantization " + paletteQuantization);\r\n    }\r\n}\r\n\n});\n\nunwrapExports(basicAPI);\nvar basicAPI_1 = basicAPI.buildPaletteSync;\nvar basicAPI_2 = basicAPI.buildPalette;\nvar basicAPI_3 = basicAPI.applyPaletteSync;\nvar basicAPI_4 = basicAPI.applyPalette;\n\nvar imageQ = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\r\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\nexports.constants = constants;\r\n\r\nexports.conversion = conversion;\r\n\r\nexports.distance = distance;\r\n\r\nexports.palette = palette$2;\r\n\r\nexports.image = image;\r\n\r\nexports.quality = quality;\r\n\r\nexports.utils = utils;\r\n\r\nexports.buildPalette = basicAPI.buildPalette;\r\nexports.buildPaletteSync = basicAPI.buildPaletteSync;\r\nexports.applyPalette = basicAPI.applyPalette;\r\nexports.applyPaletteSync = basicAPI.applyPaletteSync;\r\n\n});\n\nvar imageQ$1 = unwrapExports(imageQ);\nvar imageQ_1 = imageQ.constants;\nvar imageQ_2 = imageQ.conversion;\nvar imageQ_3 = imageQ.distance;\nvar imageQ_4 = imageQ.palette;\nvar imageQ_5 = imageQ.image;\nvar imageQ_6 = imageQ.quality;\nvar imageQ_7 = imageQ.utils;\nvar imageQ_8 = imageQ.buildPalette;\nvar imageQ_9 = imageQ.buildPaletteSync;\nvar imageQ_10 = imageQ.applyPalette;\nvar imageQ_11 = imageQ.applyPaletteSync;\n\nexports.default = imageQ$1;\nexports.constants = imageQ_1;\nexports.conversion = imageQ_2;\nexports.distance = imageQ_3;\nexports.palette = imageQ_4;\nexports.image = imageQ_5;\nexports.quality = imageQ_6;\nexports.utils = imageQ_7;\nexports.buildPalette = imageQ_8;\nexports.buildPaletteSync = imageQ_9;\nexports.applyPalette = imageQ_10;\nexports.applyPaletteSync = imageQ_11;\n\nObject.defineProperty(exports, \'__esModule\', { value: true });\n\n})));\n\n\n}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{}],2:[function(require,module,exports){\n\nfunction colorClamp(value) {\n\tif(value < 0) return 0;\n\telse if(value > 255) return 255;\n\n\treturn value;\n}\n\nvar bayerMatrix8x8 = [\n\t[  1, 49, 13, 61,  4, 52, 16, 64 ],\n\t[ 33, 17, 45, 29, 36, 20, 48, 32 ],\n\t[  9, 57,  5, 53, 12, 60,  8, 56 ],\n\t[ 41, 25, 37, 21, 44, 28, 40, 24 ],\n\t[  3, 51, 15, 63,  2, 50, 14, 62 ],\n\t[ 35, 19, 47, 31, 34, 18, 46, 30 ],\n\t[ 11, 59,  7, 55, 10, 58,  6, 54 ],\n\t[ 43, 27, 39, 23, 42, 26, 38, 22 ]\n\t];\n\n\t// int r, int g, int b, int[][] palette, int paletteLength\n\tfunction getClosestPaletteColorIndex(r, g, b, palette, paletteLength) {\n\t\tvar minDistance = 195076;\n\t\tvar diffR, diffG, diffB;\n\t\tvar distanceSquared;\n\t\tvar bestIndex = 0;\n\t\tvar paletteChannels;\n\n\t\tfor(var i = 0; i < paletteLength; i++) {\n\n\t\t\tpaletteChannels = palette[i];\n\t\t\tdiffR = r - paletteChannels[0];\n\t\t\tdiffG = g - paletteChannels[1];\n\t\t\tdiffB = b - paletteChannels[2];\n\n\t\t\tdistanceSquared = diffR*diffR + diffG*diffG + diffB*diffB;\n\n\t\t\tif(distanceSquared < minDistance) {\n\t\t\t\tbestIndex = i;\n\t\t\t\tminDistance = distanceSquared;\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestIndex;\n\t}\n\n// TODO: inPixels -> inComponents or inColors or something more accurate\nfunction BayerDithering(inPixels, width, height, palette) {\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar pixel, threshold, index;\n\tvar paletteLength = palette.length;\n\tvar matrix = bayerMatrix8x8;\n\tvar indexedPixels = new Uint8Array( width * height );\n\n\tvar modI = 8;\n\tvar modJ = 8;\n\n\tfor(var j = 0; j < height; j++) {\n\t\tvar modj = j % modJ;\n\n\t\tfor(var i = 0; i < width; i++) {\n\n\t\t\tthreshold = matrix[i % modI][modj];\n\n\t\t\tr = colorClamp( inPixels[offset++] + threshold );\n\t\t\tg = colorClamp( inPixels[offset++] + threshold );\n\t\t\tb = colorClamp( inPixels[offset++] + threshold );\n\n\t\t\tindex = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\t\t\tindexedPixels[indexedOffset++] = index;\n\n\t\t}\n\t}\n\n\treturn indexedPixels;\n}\n\n\nfunction ClosestDithering(inPixels, width, height, palette) {\n\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar index;\n\tvar paletteLength = palette.length;\n\tvar matrix = bayerMatrix8x8;\n\tvar numPixels = width * height;\n\tvar indexedPixels = new Uint8Array( numPixels );\n\n\tfor(var i = 0; i < numPixels; i++) {\n\n\t\tr = inPixels[offset++];\n\t\tg = inPixels[offset++];\n\t\tb = inPixels[offset++];\n\n\t\tindexedPixels[i] = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\n\t}\n\n\treturn indexedPixels;\n\n}\n\n\nfunction FloydSteinberg(inPixels, width, height, palette) {\n\tvar paletteLength = palette.length;\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar widthLimit = width - 1;\n\tvar heightLimit = height - 1;\n\tvar offsetNextI, offsetNextJ;\n\tvar offsetPrevINextJ;\n\tvar channels, nextChannels;\n\tvar indexedPixels = new Uint8Array( width * height );\n\n\tfor(var j = 0; j < height; j++) {\n\t\tfor(var i = 0; i < width; i++) {\n\n\t\t\tr = colorClamp(inPixels[offset++]);\n\t\t\tg = colorClamp(inPixels[offset++]);\n\t\t\tb = colorClamp(inPixels[offset++]);\n\n\t\t\tvar colorIndex = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\t\t\tvar paletteColor = palette[colorIndex];\n\t\t\tvar closestColor = paletteColor[3];\n\n\t\t\t// We are done with finding the best value for this pixel\n\t\t\tindexedPixels[indexedOffset] = colorIndex;\n\n\t\t\t// Now find difference between assigned value and original color\n\t\t\t// and propagate that error forward\n\t\t\tvar errorR = r - paletteColor[0];\n\t\t\tvar errorG = g - paletteColor[1];\n\t\t\tvar errorB = b - paletteColor[2];\n\n\t\t\tif(i < widthLimit) {\n\n\t\t\t\toffsetNextI = offset + 1;\n\n\t\t\t\tinPixels[offsetNextI++] += (errorR * 7) >> 4;\n\t\t\t\tinPixels[offsetNextI++] += (errorG * 7) >> 4;\n\t\t\t\tinPixels[offsetNextI++] += (errorB * 7) >> 4;\n\n\t\t\t}\n\n\n\t\t\tif(j < heightLimit) {\n\n\t\t\t\tif(i > 0) {\n\n\t\t\t\t\toffsetPrevINextJ = offset - 1 + width;\n\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorR * 3) >> 4;\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorG * 3) >> 4;\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorB * 3) >> 4;\n\n\t\t\t\t}\n\n\t\t\t\toffsetNextJ = offset + width;\n\n\t\t\t\tinPixels[offsetNextJ++] += (errorR * 5) >> 4;\n\t\t\t\tinPixels[offsetNextJ++] += (errorG * 5) >> 4;\n\t\t\t\tinPixels[offsetNextJ++] += (errorB * 5) >> 4;\n\n\n\t\t\t\tif(i < widthLimit) {\n\n\t\t\t\t\tinPixels[offsetNextJ++] += errorR >> 4;\n\t\t\t\t\tinPixels[offsetNextJ++] += errorG >> 4;\n\t\t\t\t\tinPixels[offsetNextJ++] += errorB >> 4;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tindexedOffset++;\n\t\t}\n\t}\n\n\treturn indexedPixels;\n}\n\nmodule.exports = {\n\tBayer: BayerDithering,\n\tClosest: ClosestDithering,\n\tFloydSteinberg: FloydSteinberg\n};\n\n\n},{}],3:[function(require,module,exports){\nvar Dithering = require(\'node-dithering\')\nconst { applyPaletteSync, buildPaletteSync, utils } = require(\'image-q\')\n\nfunction channelizePalette(palette) {\n  var channelizedPalette = []\n\n  for (var i = 0; i < palette.length; i++) {\n    var color = palette[i]\n\n    var r = (color & 0xff0000) >> 16\n    var g = (color & 0x00ff00) >> 8\n    var b = color & 0x0000ff\n\n    channelizedPalette.push([r, g, b, color])\n  }\n\n  return channelizedPalette\n}\n\n/**\n * Searches for an unused color in the image data so it can be used as a unique color\n * for transparent pixels. Builds up a set of all known colors then searches from\n * 0x000000 to 0xFFFFFF for a color not in the set. They\'re is probably a much more effecient\n * way of doing this. There is also a possibilty all colors are used, but that\'s probably\n * just a test image.\n * @param {*} data\n * @param {*} width\n * @param {*} height\n */\nfunction searchForUnusedColor(data, width, height) {\n  let i = 0\n  const length = width * height * 4\n  const knownColors = new Set()\n\n  while (i < length) {\n    const r = data[i++]\n    const g = data[i++]\n    const b = data[i++]\n    i++ // don\'t track the transparency here just the rgb values\n    const pixelColor = (r << 16) | (g << 8) | b\n    knownColors.add(pixelColor)\n  }\n\n  let unusedColor = 0x00\n  while (unusedColor < 0xffffff) {\n    if (!knownColors.has(unusedColor)) break\n    unusedColor++\n  }\n\n  return unusedColor\n}\n\nfunction dataToRGBANormalized(\n  data,\n  width,\n  height,\n  unusedColor,\n  transparencyCutOff = 0.7\n) {\n  var i = 0\n  var length = width * height * 4\n  var rgba = []\n  const transparencyCutOffValue = Math.trunc(255 * transparencyCutOff)\n\n  const unusedColorR = (unusedColor & 0xff0000) >> 16\n  const unusedColorG = (unusedColor & 0x00ff00) >> 8\n  const unusedColorB = unusedColor & 0x0000ff\n\n  while (i < length) {\n    const r = data[i++]\n    const g = data[i++]\n    const b = data[i++]\n    let a = data[i++]\n    a = a >= transparencyCutOffValue ? 0xff : 0x00\n\n    if (unusedColor !== undefined && a === 0) {\n      rgba.push(unusedColorR)\n      rgba.push(unusedColorG)\n      rgba.push(unusedColorB)\n      rgba.push(0x00)\n    } else {\n      rgba.push(r)\n      rgba.push(g)\n      rgba.push(b)\n      rgba.push(0xff)\n    }\n  }\n\n  return rgba\n}\n\nfunction componentizedPaletteToArray(paletteRGB) {\n  var paletteArray = []\n\n  for (var i = 0; i < paletteRGB.length; i += 3) {\n    var r = paletteRGB[i]\n    var g = paletteRGB[i + 1]\n    var b = paletteRGB[i + 2]\n    paletteArray.push((r << 16) | (g << 8) | b)\n  }\n\n  return paletteArray\n}\n\n/**\n * Takes an array of points from image-q and converts them to an array of sorted rgb values\n * @param {Array[Points]} points\n * returns {Array}\n */\nfunction pointsToRgb(points) {\n  return points.map(point => (point.r << 16) | (point.g << 8) | point.b)\n}\n\n/**\n * @param {Uint32Array} pixels\n * @param {Uint32Array} palette\n * @returns {Uint8Array}\n */\nfunction indexPixelsWithPalette(pixels, palette) {\n  return Uint8Array.from(pixels.map(pixel => palette.indexOf(pixel)))\n}\n\n// This is the "traditional" Animated_GIF style of going from RGBA to indexed color frames\nfunction processFrameWithQuantizer(\n  imageData,\n  width,\n  height,\n  sampleInterval,\n  searchForTransparency,\n  transparencyCutOff\n) {\n  let unusedColor\n  if (searchForTransparency) {\n    unusedColor = searchForUnusedColor(imageData, width, height)\n  }\n  const rgba = dataToRGBANormalized(\n    imageData,\n    width,\n    height,\n    unusedColor,\n    transparencyCutOff\n  )\n\n  const pointContainer = utils.PointContainer.fromUint8Array(\n    new Uint8Array(rgba),\n    width,\n    height\n  )\n  const palette = buildPaletteSync([pointContainer], {\n    paletteQuantization: \'rgbquant\',\n    colors: 255, // leave one for transparency\n  })\n  palette.add(utils.Point.createByUint32(unusedColor))\n  const outPointContainer = applyPaletteSync(pointContainer, palette)\n  const paletteRgbArray = pointsToRgb(\n    palette.getPointContainer().getPointArray()\n  )\n  paletteRgbArray.sort((a, b) => a - b)\n  const transparencyIndex = paletteRgbArray.indexOf(unusedColor)\n\n  const indexedPixels = indexPixelsWithPalette(\n    pointsToRgb(outPointContainer.getPointArray()),\n    paletteRgbArray\n  )\n\n  return {\n    pixels: indexedPixels,\n    palette: Array.from(paletteRgbArray),\n    transparencyIndex: unusedColor ? transparencyIndex : undefined,\n  }\n}\n\n// And this is a version that uses dithering against of quantizing\n// It can also use a custom palette if provided, or will build one otherwise\nfunction processFrameWithDithering(\n  imageData,\n  width,\n  height,\n  ditheringType,\n  palette\n) {\n  // Extract component values from data\n  var rgbComponents = dataToRGBANormalized(imageData, width, height)\n\n  // Build palette if none provided\n  if (palette === null) {\n    var nq = new NeuQuant(rgbComponents, rgbComponents.length, 16)\n    var paletteRGB = nq.process()\n    palette = componentizedPaletteToArray(paletteRGB)\n  }\n\n  var paletteArray = new Uint32Array(palette)\n  var paletteChannels = channelizePalette(palette)\n\n  // Convert RGB image to indexed image\n  var ditheringFunction\n\n  if (ditheringType === \'closest\') {\n    ditheringFunction = Dithering.Closest\n  } else if (ditheringType === \'floyd\') {\n    ditheringFunction = Dithering.FloydSteinberg\n  } else {\n    ditheringFunction = Dithering.Bayer\n  }\n\n  pixels = ditheringFunction(rgbComponents, width, height, paletteChannels)\n\n  return {\n    pixels: pixels,\n    palette: paletteArray,\n  }\n}\n\n// ~~~\n\nfunction run(frame) {\n  const {\n    width,\n    height,\n    data,\n    dithering,\n    palette,\n    sampleInterval,\n    searchForTransparency,\n    transparencyCutOff,\n  } = frame\n\n  if (dithering) {\n    return processFrameWithDithering(data, width, height, dithering, palette)\n  } else {\n    return processFrameWithQuantizer(\n      data,\n      width,\n      height,\n      sampleInterval,\n      searchForTransparency,\n      transparencyCutOff\n    )\n  }\n}\n\nself.onmessage = function(ev) {\n  var data = ev.data\n  var response = run(data)\n  postMessage(response)\n}\n\n},{"image-q":1,"node-dithering":2}]},{},[3]);\n'],{type:"text/javascript"})))
    workers.push(w)
    availableWorkers.push(w)
  }

  // ---

  // Return a worker for processing a frame
  function getWorker() {
    if (availableWorkers.length === 0) {
      throw 'No workers left!'
    }

    return availableWorkers.pop()
  }

  // Restore a worker to the pool
  function freeWorker(worker) {
    availableWorkers.push(worker)
  }

  // Faster/closurized bufferToString function
  // (caching the String.fromCharCode values)
  var bufferToString = (function() {
    var byteMap = []
    for (var i = 0; i < 256; i++) {
      byteMap[i] = String.fromCharCode(i)
    }

    return function(buffer) {
      var numberValues = buffer.length
      var str = ''

      for (var i = 0; i < numberValues; i++) {
        str += byteMap[buffer[i]]
      }

      return str
    }
  })()

  function startRendering(completeCallback) {
    var numFrames = frames.length

    onRenderCompleteCallback = completeCallback

    for (var i = 0; i < numWorkers && i < frames.length; i++) {
      processFrame(i)
    }
  }

  function processFrame(position) {
    var frame
    var worker

    frame = frames[position]

    if (frame.beingProcessed || frame.done) {
      console.error('Frame already being processed or done!', frame.position)
      onFrameFinished()
      return
    }

    frame.sampleInterval = sampleInterval
    frame.beingProcessed = true

    worker = getWorker()

    worker.onmessage = function(ev) {
      var data = ev.data

      // Delete original data, and free memory
      delete frame.data

      // TODO grrr... HACK for object -> Array
      frame.pixels = Array.prototype.slice.call(data.pixels)
      frame.palette = Array.prototype.slice.call(data.palette)
      frame.transparencyIndex = data.transparencyIndex
      frame.done = true
      frame.beingProcessed = false

      freeWorker(worker)

      onFrameFinished()
    }

    // TODO transfer objects should be more efficient
    /*var frameData = frame.data;
        //worker.postMessage(frameData, [frameData]);
        worker.postMessage(frameData);*/

    worker.postMessage(frame)
  }

  function processNextFrame() {
    var position = -1

    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i]
      if (!frame.done && !frame.beingProcessed) {
        position = i
        break
      }
    }

    if (position >= 0) {
      processFrame(position)
    }
  }

  function onFrameFinished() {
    // ~~~ taskFinished

    // The GIF is not written until we're done with all the frames
    // because they might not be processed in the same order
    var allDone = frames.every(function(frame) {
      return !frame.beingProcessed && frame.done
    })

    numRenderedFrames++
    onRenderProgressCallback((numRenderedFrames * 0.75) / frames.length)

    if (allDone) {
      if (!generatingGIF) {
        generateGIF(frames, onRenderCompleteCallback)
      }
    } else {
      setTimeout(processNextFrame, 1)
    }
  }

  // Takes the already processed data in frames and feeds it to a new
  // GifWriter instance in order to get the binary GIF file
  function generateGIF(frames, callback) {
    // TODO: Weird: using a simple JS array instead of a typed array,
    // the files are WAY smaller o_o. Patches/explanations welcome!
    var buffer = [] // new Uint8Array(width * height * frames.length * 5);
    var gifOptions = { loop: repeat }

    // Using global palette but only if we're also using dithering
    if (globalDithering !== null && globalPalette !== null) {
      gifOptions.palette = globalPalette
    }

    var gifWriter = new GifWriter(buffer, globalWidth, globalHeight, gifOptions)

    generatingGIF = true

    frames.forEach(function(frame) {
      var framePalette = globalPalette ? globalPalette : frame.palette

      onRenderProgressCallback(
        0.75 + (0.25 * frame.position * 1.0) / frames.length
      )

      gifWriter.addFrame(0, 0, globalWidth, globalHeight, frame.pixels, {
        palette: framePalette,
        delay: delay,
        transparent: frame.transparencyIndex,
        disposal: frame.disposal,
      })
    })

    gifWriter.end()
    onRenderProgressCallback(1.0)

    frames = []
    generatingGIF = false

    callback(buffer)
  }

  function powerOfTwo(value) {
    return value !== 0 && (value & (value - 1)) === 0
  }

  // ---

  this.setSize = function(w, h) {
    globalWidth = w
    globalHeight = h
    canvas = document.createElement('canvas')
    canvas.width = w
    canvas.height = h
    ctx = canvas.getContext('2d')
  }

  // Internally, GIF uses tenths of seconds to store the delay
  this.setDelay = function(seconds) {
    delay = seconds * 0.1
  }

  // From GIF: 0 = loop forever, null = not looping, n > 0 = loop n times and stop
  this.setRepeat = function(r) {
    repeat = r
  }

  this.addFrame = function(element, options = {}) {
    if (ctx === null) {
      this.setSize(globalWidth, globalHeight)
    }
    // clear the canvas because drawing over other frames breaks transparency
    ctx.clearRect(0, 0, globalWidth, globalHeight)
    ctx.drawImage(element, 0, 0, globalWidth, globalHeight)
    var imageData = ctx.getImageData(0, 0, globalWidth, globalHeight)

    this.addFrameImageData(imageData, (options = {}))
  }

  this.addFrameImageData = function(imageData, options = {}) {
    var imageDataArray = new Uint8Array(imageData.data)

    frames.push({
      data: imageDataArray,
      width: imageData.width,
      height: imageData.height,
      palette: options.palette || globalPalette,
      dithering: options.dithering || globalDithering,
      disposal: options.disposal || globalDisposal,
      transparencyCutOff:
        options.transparencyCutOff || globalTransparencyCutOff,
      done: false,
      beingProcessed: false,
      position: frames.length,
      searchForTransparency: searchForTransparency,
    })
  }

  this.onRenderProgress = function(callback) {
    onRenderProgressCallback = callback
  }

  this.isRendering = function() {
    return generatingGIF
  }

  this.getBase64GIF = function(completeCallback) {
    var onRenderComplete = function(buffer) {
      var str = bufferToString(buffer)
      var gif = 'data:image/gif;base64,' + btoa(str)
      completeCallback(gif)
    }

    startRendering(onRenderComplete)
  }

  this.getBlobGIF = function(completeCallback) {
    var onRenderComplete = function(buffer) {
      var array = new Uint8Array(buffer)
      var blob = new Blob([array], { type: 'image/gif' })
      completeCallback(blob)
    }

    startRendering(onRenderComplete)
  }

  // Once this function is called, the object becomes unusable
  // and you'll need to create a new one.
  this.destroy = function() {
    // Explicitly ask web workers to die so they are explicitly GC'ed
    workers.forEach(function(w) {
      w.terminate()
    })
  }
}

// Not using the full blown exporter because this is supposed to be built
// into dist/Animated_GIF.js using a build step with browserify
module.exports = Animated_GIF

},{"omggif":1}]},{},[2])(2)
});
