(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Animated_GIF = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";function GifWriter(r,e,t,n){var i=0,a=void 0===(n=void 0===n?{}:n).loop?null:n.loop,o=void 0===n.palette?null:n.palette;if(e<=0||t<=0||e>65535||t>65535)throw new Error("Width/Height invalid.");function f(r){var e=r.length;if(e<2||e>256||e&e-1)throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");return e}r[i++]=71,r[i++]=73,r[i++]=70,r[i++]=56,r[i++]=57,r[i++]=97;var l=0,u=0;if(null!==o){for(var h=f(o);h>>=1;)++l;if(h=1<<l,--l,void 0!==n.background){if((u=n.background)>=h)throw new Error("Background index out of range.");if(0===u)throw new Error("Background index explicitly passed as 0.")}}if(r[i++]=255&e,r[i++]=e>>8&255,r[i++]=255&t,r[i++]=t>>8&255,r[i++]=(null!==o?128:0)|l,r[i++]=u,r[i++]=0,null!==o)for(var d=0,s=o.length;d<s;++d){var v=o[d];r[i++]=v>>16&255,r[i++]=v>>8&255,r[i++]=255&v}if(null!==a){if(a<0||a>65535)throw new Error("Loop count invalid.");r[i++]=33,r[i++]=255,r[i++]=11,r[i++]=78,r[i++]=69,r[i++]=84,r[i++]=83,r[i++]=67,r[i++]=65,r[i++]=80,r[i++]=69,r[i++]=50,r[i++]=46,r[i++]=48,r[i++]=3,r[i++]=1,r[i++]=255&a,r[i++]=a>>8&255,r[i++]=0}var c=!1;this.addFrame=function(e,t,n,a,l,u){if(!0===c&&(--i,c=!1),u=void 0===u?{}:u,e<0||t<0||e>65535||t>65535)throw new Error("x/y invalid.");if(n<=0||a<=0||n>65535||a>65535)throw new Error("Width/Height invalid.");if(l.length<n*a)throw new Error("Not enough pixels for the frame size.");var h=!0,d=u.palette;if(null==d&&(h=!1,d=o),null==d)throw new Error("Must supply either a local or global palette.");for(var s=f(d),v=0;s>>=1;)++v;s=1<<v;var w=void 0===u.delay?0:u.delay,p=void 0===u.disposal?0:u.disposal;if(p<0||p>3)throw new Error("Disposal out of range.");var g=!1,x=0;if(void 0!==u.transparent&&null!==u.transparent&&(g=!0,(x=u.transparent)<0||x>=s))throw new Error("Transparent color index.");if((0!==p||g||0!==w)&&(r[i++]=33,r[i++]=249,r[i++]=4,r[i++]=p<<2|(!0===g?1:0),r[i++]=255&w,r[i++]=w>>8&255,r[i++]=x,r[i++]=0),r[i++]=44,r[i++]=255&e,r[i++]=e>>8&255,r[i++]=255&t,r[i++]=t>>8&255,r[i++]=255&n,r[i++]=n>>8&255,r[i++]=255&a,r[i++]=a>>8&255,r[i++]=!0===h?128|v-1:0,!0===h)for(var k=0,b=d.length;k<b;++k){var E=d[k];r[i++]=E>>16&255,r[i++]=E>>8&255,r[i++]=255&E}return i=GifWriterOutputLZWCodeStream(r,i,v<2?2:v,l)},this.end=function(){return!1===c&&(r[i++]=59,c=!0),i},this.getOutputBuffer=function(){return r},this.setOutputBuffer=function(e){r=e},this.getOutputBufferPosition=function(){return i},this.setOutputBufferPosition=function(r){i=r}}function GifWriterOutputLZWCodeStream(r,e,t,n){r[e++]=t;var i=e++,a=1<<t,o=a-1,f=a+1,l=f+1,u=t+1,h=0,d=0;function s(t){for(;h>=t;)r[e++]=255&d,d>>=8,h-=8,e===i+256&&(r[i]=255,i=e++)}function v(r){d|=r<<h,h+=u,s(8)}var c=n[0]&o,w={};v(a);for(var p=1,g=n.length;p<g;++p){var x=n[p]&o,k=c<<8|x,b=w[k];if(void 0===b){for(d|=c<<h,h+=u;h>=8;)r[e++]=255&d,d>>=8,h-=8,e===i+256&&(r[i]=255,i=e++);4096===l?(v(a),l=f+1,u=t+1,w={}):(l>=1<<u&&++u,w[k]=l++),c=x}else c=b}return v(c),v(f),s(1),i+1===e?r[i]=0:(r[i]=e-i-1,r[e++]=0),e}function GifReader(r){var e=0;if(71!==r[e++]||73!==r[e++]||70!==r[e++]||56!==r[e++]||56!=(r[e++]+1&253)||97!==r[e++])throw new Error("Invalid GIF 87a/89a header.");var t=r[e++]|r[e++]<<8,n=r[e++]|r[e++]<<8,i=r[e++],a=i>>7,o=1<<(7&i)+1;r[e++];r[e++];var f=null,l=null;a&&(f=e,l=o,e+=3*o);var u=!0,h=[],d=0,s=null,v=0,c=null;for(this.width=t,this.height=n;u&&e<r.length;)switch(r[e++]){case 33:switch(r[e++]){case 255:if(11!==r[e]||78==r[e+1]&&69==r[e+2]&&84==r[e+3]&&83==r[e+4]&&67==r[e+5]&&65==r[e+6]&&80==r[e+7]&&69==r[e+8]&&50==r[e+9]&&46==r[e+10]&&48==r[e+11]&&3==r[e+12]&&1==r[e+13]&&0==r[e+16])e+=14,c=r[e++]|r[e++]<<8,e++;else for(e+=12;;){if(!((_=r[e++])>=0))throw Error("Invalid block size");if(0===_)break;e+=_}break;case 249:if(4!==r[e++]||0!==r[e+4])throw new Error("Invalid graphics extension block.");var w=r[e++];d=r[e++]|r[e++]<<8,s=r[e++],0==(1&w)&&(s=null),v=w>>2&7,e++;break;case 254:for(;;){if(!((_=r[e++])>=0))throw Error("Invalid block size");if(0===_)break;e+=_}break;default:throw new Error("Unknown graphic control label: 0x"+r[e-1].toString(16))}break;case 44:var p=r[e++]|r[e++]<<8,g=r[e++]|r[e++]<<8,x=r[e++]|r[e++]<<8,k=r[e++]|r[e++]<<8,b=r[e++],E=b>>6&1,m=1<<(7&b)+1,y=f,G=l,I=!1;if(b>>7){I=!0;y=e,G=m,e+=3*m}var W=e;for(e++;;){var _;if(!((_=r[e++])>=0))throw Error("Invalid block size");if(0===_)break;e+=_}h.push({x:p,y:g,width:x,height:k,has_local_palette:I,palette_offset:y,palette_size:G,data_offset:W,data_length:e-W,transparent_index:s,interlaced:!!E,delay:d,disposal:v});break;case 59:u=!1;break;default:throw new Error("Unknown gif block: 0x"+r[e-1].toString(16))}this.numFrames=function(){return h.length},this.loopCount=function(){return c},this.frameInfo=function(r){if(r<0||r>=h.length)throw new Error("Frame index out of range.");return h[r]},this.decodeAndBlitFrameBGRA=function(e,n){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);GifReaderLZWOutputIndexStream(r,i.data_offset,o,a);var f=i.palette_offset,l=i.transparent_index;null===l&&(l=256);var u=i.width,h=t-u,d=u,s=4*(i.y*t+i.x),v=4*((i.y+i.height)*t+i.x),c=s,w=4*h;!0===i.interlaced&&(w+=4*t*7);for(var p=8,g=0,x=o.length;g<x;++g){var k=o[g];if(0===d&&(d=u,(c+=w)>=v&&(w=4*h+4*t*(p-1),c=s+(u+h)*(p<<1),p>>=1)),k===l)c+=4;else{var b=r[f+3*k],E=r[f+3*k+1],m=r[f+3*k+2];n[c++]=m,n[c++]=E,n[c++]=b,n[c++]=255}--d}},this.decodeAndBlitFrameRGBA=function(e,n){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);GifReaderLZWOutputIndexStream(r,i.data_offset,o,a);var f=i.palette_offset,l=i.transparent_index;null===l&&(l=256);var u=i.width,h=t-u,d=u,s=4*(i.y*t+i.x),v=4*((i.y+i.height)*t+i.x),c=s,w=4*h;!0===i.interlaced&&(w+=4*t*7);for(var p=8,g=0,x=o.length;g<x;++g){var k=o[g];if(0===d&&(d=u,(c+=w)>=v&&(w=4*h+4*t*(p-1),c=s+(u+h)*(p<<1),p>>=1)),k===l)c+=4;else{var b=r[f+3*k],E=r[f+3*k+1],m=r[f+3*k+2];n[c++]=b,n[c++]=E,n[c++]=m,n[c++]=255}--d}}}function GifReaderLZWOutputIndexStream(r,e,t,n){for(var i=r[e++],a=1<<i,o=a+1,f=o+1,l=i+1,u=(1<<l)-1,h=0,d=0,s=0,v=r[e++],c=new Int32Array(4096),w=null;;){for(;h<16&&0!==v;)d|=r[e++]<<h,h+=8,1===v?v=r[e++]:--v;if(h<l)break;var p=d&u;if(d>>=l,h-=l,p!==a){if(p===o)break;for(var g=p<f?p:w,x=0,k=g;k>a;)k=c[k]>>8,++x;var b=k;if(s+x+(g!==p?1:0)>n)return void console.log("Warning, gif stream longer than expected.");t[s++]=b;var E=s+=x;for(g!==p&&(t[s++]=b),k=g;x--;)k=c[k],t[--E]=255&k,k>>=8;null!==w&&f<4096&&(c[f++]=w<<8|b,f>=u+1&&l<12&&(++l,u=u<<1|1)),w=p}else f=o+1,u=(1<<(l=i+1))-1,w=null}return s!==n&&console.log("Warning, gif stream shorter than expected."),t}try{exports.GifWriter=GifWriter,exports.GifReader=GifReader}catch(r){}

},{}],2:[function(require,module,exports){
function Animated_GIF(n){"use strict";n=n||{};var t=require("omggif").GifWriter;console.log("not in the woredk dgfk");var e,i,a=n.width||160,r=n.height||120,s=n.dithering||null,o=n.palette||null,l=null,d=null,f=0,p=250,h=[],u=0,c=function(){},g=function(){},v=[],b=[],m=!1;if(o){if(!(o instanceof Array))throw o;if(o.length<2||o.length>256){for(console.error("Palette must hold only between 2 and 256 colours");o.length<2;)o.push(0);o.length>256&&(o=o.slice(0,256))}if(!q(o.length))for(console.error("Palette must have a power of two number of colours");!q(o.length);)o.splice(o.length-1,1)}e=(n=n||{}).sampleInterval||10,i=n.numWorkers||2;for(var x=0;x<i;x++){var w=new Worker((window.URL||window.webkitURL).createObjectURL(new Blob(['(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module \'"+i+"\'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\nfunction colorClamp(value) {\n\tif(value < 0) return 0;\n\telse if(value > 255) return 255;\n\n\treturn value;\n}\n\nvar bayerMatrix8x8 = [\n\t[  1, 49, 13, 61,  4, 52, 16, 64 ],\n\t[ 33, 17, 45, 29, 36, 20, 48, 32 ],\n\t[  9, 57,  5, 53, 12, 60,  8, 56 ],\n\t[ 41, 25, 37, 21, 44, 28, 40, 24 ],\n\t[  3, 51, 15, 63,  2, 50, 14, 62 ],\n\t[ 35, 19, 47, 31, 34, 18, 46, 30 ],\n\t[ 11, 59,  7, 55, 10, 58,  6, 54 ],\n\t[ 43, 27, 39, 23, 42, 26, 38, 22 ]\n\t];\n\n\t// int r, int g, int b, int[][] palette, int paletteLength\n\tfunction getClosestPaletteColorIndex(r, g, b, palette, paletteLength) {\n\t\tvar minDistance = 195076;\n\t\tvar diffR, diffG, diffB;\n\t\tvar distanceSquared;\n\t\tvar bestIndex = 0;\n\t\tvar paletteChannels;\n\n\t\tfor(var i = 0; i < paletteLength; i++) {\n\n\t\t\tpaletteChannels = palette[i];\n\t\t\tdiffR = r - paletteChannels[0];\n\t\t\tdiffG = g - paletteChannels[1];\n\t\t\tdiffB = b - paletteChannels[2];\n\n\t\t\tdistanceSquared = diffR*diffR + diffG*diffG + diffB*diffB;\n\n\t\t\tif(distanceSquared < minDistance) {\n\t\t\t\tbestIndex = i;\n\t\t\t\tminDistance = distanceSquared;\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestIndex;\n\t}\n\n// TODO: inPixels -> inComponents or inColors or something more accurate\nfunction BayerDithering(inPixels, width, height, palette) {\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar pixel, threshold, index;\n\tvar paletteLength = palette.length;\n\tvar matrix = bayerMatrix8x8;\n\tvar indexedPixels = new Uint8Array( width * height );\n\n\tvar modI = 8;\n\tvar modJ = 8;\n\n\tfor(var j = 0; j < height; j++) {\n\t\tvar modj = j % modJ;\n\n\t\tfor(var i = 0; i < width; i++) {\n\n\t\t\tthreshold = matrix[i % modI][modj];\n\n\t\t\tr = colorClamp( inPixels[offset++] + threshold );\n\t\t\tg = colorClamp( inPixels[offset++] + threshold );\n\t\t\tb = colorClamp( inPixels[offset++] + threshold );\n\n\t\t\tindex = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\t\t\tindexedPixels[indexedOffset++] = index;\n\n\t\t}\n\t}\n\n\treturn indexedPixels;\n}\n\n\nfunction ClosestDithering(inPixels, width, height, palette) {\n\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar index;\n\tvar paletteLength = palette.length;\n\tvar matrix = bayerMatrix8x8;\n\tvar numPixels = width * height;\n\tvar indexedPixels = new Uint8Array( numPixels );\n\n\tfor(var i = 0; i < numPixels; i++) {\n\n\t\tr = inPixels[offset++];\n\t\tg = inPixels[offset++];\n\t\tb = inPixels[offset++];\n\n\t\tindexedPixels[i] = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\n\t}\n\n\treturn indexedPixels;\n\n}\n\n\nfunction FloydSteinberg(inPixels, width, height, palette) {\n\tvar paletteLength = palette.length;\n\tvar offset = 0;\n\tvar indexedOffset = 0;\n\tvar r, g, b;\n\tvar widthLimit = width - 1;\n\tvar heightLimit = height - 1;\n\tvar offsetNextI, offsetNextJ;\n\tvar offsetPrevINextJ;\n\tvar channels, nextChannels;\n\tvar indexedPixels = new Uint8Array( width * height );\n\n\tfor(var j = 0; j < height; j++) {\n\t\tfor(var i = 0; i < width; i++) {\n\n\t\t\tr = colorClamp(inPixels[offset++]);\n\t\t\tg = colorClamp(inPixels[offset++]);\n\t\t\tb = colorClamp(inPixels[offset++]);\n\n\t\t\tvar colorIndex = getClosestPaletteColorIndex(r, g, b, palette, paletteLength);\n\t\t\tvar paletteColor = palette[colorIndex];\n\t\t\tvar closestColor = paletteColor[3];\n\n\t\t\t// We are done with finding the best value for this pixel\n\t\t\tindexedPixels[indexedOffset] = colorIndex;\n\n\t\t\t// Now find difference between assigned value and original color\n\t\t\t// and propagate that error forward\n\t\t\tvar errorR = r - paletteColor[0];\n\t\t\tvar errorG = g - paletteColor[1];\n\t\t\tvar errorB = b - paletteColor[2];\n\n\t\t\tif(i < widthLimit) {\n\n\t\t\t\toffsetNextI = offset + 1;\n\n\t\t\t\tinPixels[offsetNextI++] += (errorR * 7) >> 4;\n\t\t\t\tinPixels[offsetNextI++] += (errorG * 7) >> 4;\n\t\t\t\tinPixels[offsetNextI++] += (errorB * 7) >> 4;\n\n\t\t\t}\n\n\n\t\t\tif(j < heightLimit) {\n\n\t\t\t\tif(i > 0) {\n\n\t\t\t\t\toffsetPrevINextJ = offset - 1 + width;\n\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorR * 3) >> 4;\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorG * 3) >> 4;\n\t\t\t\t\tinPixels[offsetPrevINextJ++] += (errorB * 3) >> 4;\n\n\t\t\t\t}\n\n\t\t\t\toffsetNextJ = offset + width;\n\n\t\t\t\tinPixels[offsetNextJ++] += (errorR * 5) >> 4;\n\t\t\t\tinPixels[offsetNextJ++] += (errorG * 5) >> 4;\n\t\t\t\tinPixels[offsetNextJ++] += (errorB * 5) >> 4;\n\n\n\t\t\t\tif(i < widthLimit) {\n\n\t\t\t\t\tinPixels[offsetNextJ++] += errorR >> 4;\n\t\t\t\t\tinPixels[offsetNextJ++] += errorG >> 4;\n\t\t\t\t\tinPixels[offsetNextJ++] += errorB >> 4;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tindexedOffset++;\n\t\t}\n\t}\n\n\treturn indexedPixels;\n}\n\nmodule.exports = {\n\tBayer: BayerDithering,\n\tClosest: ClosestDithering,\n\tFloydSteinberg: FloydSteinberg\n};\n\n\n},{}],2:[function(require,module,exports){\nvar NeuQuant = require(\'./lib/NeuQuant\')\nvar Dithering = require(\'node-dithering\')\n\nfunction channelizePalette(palette) {\n  var channelizedPalette = []\n\n  for (var i = 0; i < palette.length; i++) {\n    var color = palette[i]\n\n    var r = (color & 0xff0000) >> 16\n    var g = (color & 0x00ff00) >> 8\n    var b = color & 0x0000ff\n\n    channelizedPalette.push([r, g, b, color])\n  }\n\n  return channelizedPalette\n}\n\n/**\n * Searches for an unused color in the image data so it can be used as a unique color\n * for transparent pixels. Builds up a set of all known colors then searches from\n * 0x000000 to 0xFFFFFF for a color not in the set. They\'re is probably a much more effecient\n * way of doing this. There is also a possibilty all colors are used, but that\'s probably\n * just a test image.\n * @param {*} data\n * @param {*} width\n * @param {*} height\n */\nfunction searchForUnusedColor(data, width, height) {\n  let i = 0\n  const length = width * height * 4\n  const knownColors = new Set()\n\n  while (i < length) {\n    const r = data[i++]\n    const g = data[i++]\n    const b = data[i++]\n    i++ // don\'t track the transparency here just the rgb values\n    const pixelColor = (r << 16) | (g << 8) | b\n    knownColors.add(pixelColor)\n  }\n\n  let unusedColor = 0x00\n  while (unusedColor < 0xffffff) {\n    if (!knownColors.has(unusedColor)) break\n    unusedColor++\n  }\n\n  return unusedColor\n}\n\nfunction dataToRGB(data, width, height, unusedColor) {\n  var i = 0\n  var length = width * height * 4\n  var rgb = []\n\n  const unusedColorR = (unusedColor & 0xff0000) >> 16\n  const unusedColorG = (unusedColor & 0x00ff00) >> 8\n  const unusedColorB = unusedColor & 0x0000ff\n\n  while (i < length) {\n    const r = data[i++]\n    const g = data[i++]\n    const b = data[i++]\n    const a = data[i++]\n\n    if (a) {\n      rgb.push(r)\n      rgb.push(g)\n      rgb.push(b)\n    } else {\n      rgb.push(unusedColorR)\n      rgb.push(unusedColorG)\n      rgb.push(unusedColorB)\n    }\n  }\n\n  return rgb\n}\n\nfunction componentizedPaletteToArray(paletteRGB) {\n  var paletteArray = []\n\n  for (var i = 0; i < paletteRGB.length; i += 3) {\n    var r = paletteRGB[i]\n    var g = paletteRGB[i + 1]\n    var b = paletteRGB[i + 2]\n    paletteArray.push((r << 16) | (g << 8) | b)\n  }\n\n  return paletteArray\n}\n\n// This is the "traditional" Animated_GIF style of going from RGBA to indexed color frames\nfunction processFrameWithQuantizer(imageData, width, height, sampleInterval) {\n  const unusedColor = searchForUnusedColor(imageData, width, height)\n  var rgbComponents = dataToRGB(imageData, width, height, unusedColor)\n  var nq = new NeuQuant(rgbComponents, rgbComponents.length, sampleInterval)\n  var paletteRGB = nq.process()\n  var paletteArray = new Uint32Array(componentizedPaletteToArray(paletteRGB))\n\n  var numberPixels = width * height\n  var indexedPixels = new Uint8Array(numberPixels)\n\n  var k = 0\n  for (var i = 0; i < numberPixels; i++) {\n    r = rgbComponents[k++]\n    g = rgbComponents[k++]\n    b = rgbComponents[k++]\n    indexedPixels[i] = nq.map(r, g, b)\n  }\n\n  const data = {\n    pixels: indexedPixels,\n    palette: paletteArray,\n  }\n\n  // Try and get the index of the transparent color in the palette\n  for (let i = 0; i < paletteArray.length; i++) {\n    if (paletteArray[i] === unusedColor) {\n      data.transparencyIndex = i\n      break\n    }\n  }\n\n  return data\n}\n\n// And this is a version that uses dithering against of quantizing\n// It can also use a custom palette if provided, or will build one otherwise\nfunction processFrameWithDithering(\n  imageData,\n  width,\n  height,\n  ditheringType,\n  palette\n) {\n  // Extract component values from data\n  var rgbComponents = dataToRGB(imageData, width, height)\n\n  // Build palette if none provided\n  if (palette === null) {\n    var nq = new NeuQuant(rgbComponents, rgbComponents.length, 16)\n    var paletteRGB = nq.process()\n    palette = componentizedPaletteToArray(paletteRGB)\n  }\n\n  var paletteArray = new Uint32Array(palette)\n  var paletteChannels = channelizePalette(palette)\n\n  // Convert RGB image to indexed image\n  var ditheringFunction\n\n  if (ditheringType === \'closest\') {\n    ditheringFunction = Dithering.Closest\n  } else if (ditheringType === \'floyd\') {\n    ditheringFunction = Dithering.FloydSteinberg\n  } else {\n    ditheringFunction = Dithering.Bayer\n  }\n\n  pixels = ditheringFunction(rgbComponents, width, height, paletteChannels)\n\n  return {\n    pixels: pixels,\n    palette: paletteArray,\n  }\n}\n\n// ~~~\n\nfunction run(frame) {\n  console.log(\'in the worker\')\n  var width = frame.width\n  var height = frame.height\n  var imageData = frame.data\n  var dithering = frame.dithering\n  var palette = frame.palette\n  var sampleInterval = frame.sampleInterval\n\n  if (dithering) {\n    return processFrameWithDithering(\n      imageData,\n      width,\n      height,\n      dithering,\n      palette\n    )\n  } else {\n    return processFrameWithQuantizer(imageData, width, height, sampleInterval)\n  }\n}\n\nself.onmessage = function(ev) {\n  var data = ev.data\n  var response = run(data)\n  postMessage(response)\n}\n\n},{"./lib/NeuQuant":3,"node-dithering":1}],3:[function(require,module,exports){\n/*\n* NeuQuant Neural-Net Quantization Algorithm\n* ------------------------------------------\n*\n* Copyright (c) 1994 Anthony Dekker\n*\n* NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n* "Kohonen neural networks for optimal colour quantization" in "Network:\n* Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of\n* the algorithm.\n*\n* Any party obtaining a copy of these files from the author, directly or\n* indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n* world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n* this software and documentation files (the "Software"), including without\n* limitation the rights to use, copy, modify, merge, publish, distribute,\n* sublicense, and/or sell copies of the Software, and to permit persons who\n* receive copies from any such party to do so, with the only requirement being\n* that this copyright notice remain intact.\n*/\n\n/*\n* This class handles Neural-Net quantization algorithm\n* @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n* @author Thibault Imbert (AS3 version - bytearray.org)\n* @version 0.1 AS3 implementation\n* @version 0.2 JS->AS3 "translation" by antimatter15\n* @version 0.3 JS clean up + using modern JS idioms by sole - http://soledadpenades.com\n* Also implement fix in color conversion described at http://stackoverflow.com/questions/16371712/neuquant-js-javascript-color-quantization-hidden-bug-in-js-conversion\n*/\n\nmodule.exports = function NeuQuant() {\n\n    var netsize = 256; // number of colours used\n\n    // four primes near 500 - assume no image has a length so large\n    // that it is divisible by all four primes\n    var prime1 = 499;\n    var prime2 = 491;\n    var prime3 = 487;\n    var prime4 = 503;\n\n    // minimum size for input image\n    var minpicturebytes = (3 * prime4);\n\n    // Network Definitions\n\n    var maxnetpos = (netsize - 1);\n    var netbiasshift = 4; // bias for colour values\n    var ncycles = 100; // no. of learning cycles\n\n    // defs for freq and bias\n    var intbiasshift = 16; // bias for fractions\n    var intbias = (1 << intbiasshift);\n    var gammashift = 10; // gamma = 1024\n    var gamma = (1 << gammashift);\n    var betashift = 10;\n    var beta = (intbias >> betashift); // beta = 1/1024\n    var betagamma = (intbias << (gammashift - betashift));\n\n    // defs for decreasing radius factor\n    // For 256 colors, radius starts at 32.0 biased by 6 bits\n    // and decreases by a factor of 1/30 each cycle\n    var initrad = (netsize >> 3);\n    var radiusbiasshift = 6;\n    var radiusbias = (1 << radiusbiasshift);\n    var initradius = (initrad * radiusbias);\n    var radiusdec = 30;\n\n    // defs for decreasing alpha factor\n    // Alpha starts at 1.0 biased by 10 bits\n    var alphabiasshift = 10;\n    var initalpha = (1 << alphabiasshift);\n    var alphadec;\n\n    // radbias and alpharadbias used for radpower calculation\n    var radbiasshift = 8;\n    var radbias = (1 << radbiasshift);\n    var alpharadbshift = (alphabiasshift + radbiasshift);\n    var alpharadbias = (1 << alpharadbshift);\n\n\n    // Input image\n    var thepicture;\n    // Height * Width * 3\n    var lengthcount;\n    // Sampling factor 1..30\n    var samplefac;\n\n    // The network itself\n    var network;\n    var netindex = [];\n\n    // for network lookup - really 256\n    var bias = [];\n\n    // bias and freq arrays for learning\n    var freq = [];\n    var radpower = [];\n\n    function NeuQuantConstructor(thepic, len, sample) {\n\n        var i;\n        var p;\n\n        thepicture = thepic;\n        lengthcount = len;\n        samplefac = sample;\n\n        network = new Array(netsize);\n\n        for (i = 0; i < netsize; i++) {\n            network[i] = new Array(4);\n            p = network[i];\n            p[0] = p[1] = p[2] = ((i << (netbiasshift + 8)) / netsize) | 0;\n            freq[i] = (intbias / netsize) | 0; // 1 / netsize\n            bias[i] = 0;\n        }\n\n    }\n\n    function colorMap() {\n        var map = [];\n        var index = new Array(netsize);\n        for (var i = 0; i < netsize; i++)\n            index[network[i][3]] = i;\n        var k = 0;\n        for (var l = 0; l < netsize; l++) {\n            var j = index[l];\n            map[k++] = (network[j][0]);\n            map[k++] = (network[j][1]);\n            map[k++] = (network[j][2]);\n        }\n        return map;\n    }\n\n    // Insertion sort of network and building of netindex[0..255]\n    // (to do after unbias)\n    function inxbuild() {\n        var i;\n        var j;\n        var smallpos;\n        var smallval;\n        var p;\n        var q;\n        var previouscol;\n        var startpos;\n\n        previouscol = 0;\n        startpos = 0;\n\n        for (i = 0; i < netsize; i++)\n        {\n\n            p = network[i];\n            smallpos = i;\n            smallval = p[1]; // index on g\n            // find smallest in i..netsize-1\n            for (j = i + 1; j < netsize; j++) {\n\n                q = network[j];\n\n                if (q[1] < smallval) { // index on g\n                    smallpos = j;\n                    smallval = q[1]; // index on g\n                }\n            }\n\n            q = network[smallpos];\n\n            // swap p (i) and q (smallpos) entries\n            if (i != smallpos) {\n                j = q[0];\n                q[0] = p[0];\n                p[0] = j;\n                j = q[1];\n                q[1] = p[1];\n                p[1] = j;\n                j = q[2];\n                q[2] = p[2];\n                p[2] = j;\n                j = q[3];\n                q[3] = p[3];\n                p[3] = j;\n            }\n\n            // smallval entry is now in position i\n            if (smallval != previouscol) {\n\n                netindex[previouscol] = (startpos + i) >> 1;\n\n                for (j = previouscol + 1; j < smallval; j++) {\n                    netindex[j] = i;\n                }\n\n                previouscol = smallval;\n                startpos = i;\n\n            }\n\n        }\n\n        netindex[previouscol] = (startpos + maxnetpos) >> 1;\n        for (j = previouscol + 1; j < 256; j++) {\n            netindex[j] = maxnetpos; // really 256\n        }\n\n    }\n\n\n    // Main Learning Loop\n\n    function learn() {\n        var i;\n        var j;\n        var b;\n        var g;\n        var r;\n        var radius;\n        var rad;\n        var alpha;\n        var step;\n        var delta;\n        var samplepixels;\n        var p;\n        var pix;\n        var lim;\n\n        if (lengthcount < minpicturebytes) {\n            samplefac = 1;\n        }\n\n        alphadec = 30 + ((samplefac - 1) / 3);\n        p = thepicture;\n        pix = 0;\n        lim = lengthcount;\n        samplepixels = lengthcount / (3 * samplefac);\n        delta = (samplepixels / ncycles) | 0;\n        alpha = initalpha;\n        radius = initradius;\n\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) {\n            rad = 0;\n        }\n\n        for (i = 0; i < rad; i++) {\n            radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n        }\n\n\n        if (lengthcount < minpicturebytes) {\n            step = 3;\n        } else if ((lengthcount % prime1) !== 0) {\n            step = 3 * prime1;\n        } else {\n\n            if ((lengthcount % prime2) !== 0) {\n                step = 3 * prime2;\n            } else {\n                if ((lengthcount % prime3) !== 0) {\n                    step = 3 * prime3;\n                } else {\n                    step = 3 * prime4;\n                }\n            }\n\n        }\n\n        i = 0;\n\n        while (i < samplepixels) {\n\n            b = (p[pix + 0] & 0xff) << netbiasshift;\n            g = (p[pix + 1] & 0xff) << netbiasshift;\n            r = (p[pix + 2] & 0xff) << netbiasshift;\n            j = contest(b, g, r);\n\n            altersingle(alpha, j, b, g, r);\n\n            if (rad !== 0) {\n                // Alter neighbours\n                alterneigh(rad, j, b, g, r);\n            }\n\n            pix += step;\n\n            if (pix >= lim) {\n                pix -= lengthcount;\n            }\n\n            i++;\n\n            if (delta === 0) {\n                delta = 1;\n            }\n\n            if (i % delta === 0) {\n                alpha -= alpha / alphadec;\n                radius -= radius / radiusdec;\n                rad = radius >> radiusbiasshift;\n\n                if (rad <= 1) {\n                    rad = 0;\n                }\n\n                for (j = 0; j < rad; j++) {\n                    radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n                }\n\n            }\n\n        }\n\n    }\n\n    // Search for BGR values 0..255 (after net is unbiased) and return colour index\n    function map(b, g, r) {\n        var i;\n        var j;\n        var dist;\n        var a;\n        var bestd;\n        var p;\n        var best;\n\n        // Biggest possible distance is 256 * 3\n        bestd = 1000;\n        best = -1;\n        i = netindex[g]; // index on g\n        j = i - 1; // start at netindex[g] and work outwards\n\n        while ((i < netsize) || (j >= 0)) {\n\n            if (i < netsize) {\n\n                p = network[i];\n\n                dist = p[1] - g; // inx key\n\n                if (dist >= bestd) {\n                    i = netsize; // stop iter\n                } else {\n\n                    i++;\n\n                    if (dist < 0) {\n                        dist = -dist;\n                    }\n\n                    a = p[0] - b;\n\n                    if (a < 0) {\n                        a = -a;\n                    }\n\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n\n                        if (a < 0) {\n                            a = -a;\n                        }\n\n                        dist += a;\n\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n\n                }\n\n            }\n\n            if (j >= 0) {\n\n                p = network[j];\n\n                dist = g - p[1]; // inx key - reverse dif\n\n                if (dist >= bestd) {\n                    j = -1; // stop iter\n                } else {\n\n                    j--;\n                    if (dist < 0) {\n                        dist = -dist;\n                    }\n                    a = p[0] - b;\n                    if (a < 0) {\n                        a = -a;\n                    }\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0) {\n                            a = -a;\n                        }\n                        dist += a;\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n\n                }\n\n            }\n\n        }\n\n        return (best);\n\n    }\n\n    function process() {\n        learn();\n        unbiasnet();\n        inxbuild();\n        return colorMap();\n    }\n\n    // Unbias network to give byte values 0..255 and record position i\n    // to prepare for sort\n    function unbiasnet() {\n        var i;\n        var j;\n\n        for (i = 0; i < netsize; i++) {\n            network[i][0] >>= netbiasshift;\n            network[i][1] >>= netbiasshift;\n            network[i][2] >>= netbiasshift;\n            network[i][3] = i; // record colour no\n        }\n    }\n\n    // Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2))\n    // in radpower[|i-j|]\n    function alterneigh(rad, i, b, g, r) {\n\n        var j;\n        var k;\n        var lo;\n        var hi;\n        var a;\n        var m;\n\n        var p;\n\n        lo = i - rad;\n        if (lo < -1) {\n            lo = -1;\n        }\n\n        hi = i + rad;\n\n        if (hi > netsize) {\n            hi = netsize;\n        }\n\n        j = i + 1;\n        k = i - 1;\n        m = 1;\n\n        while ((j < hi) || (k > lo)) {\n\n            a = radpower[m++];\n\n            if (j < hi) {\n\n                p = network[j++];\n\n                try {\n\n                    p[0] -= ((a * (p[0] - b)) / alpharadbias) | 0;\n                    p[1] -= ((a * (p[1] - g)) / alpharadbias) | 0;\n                    p[2] -= ((a * (p[2] - r)) / alpharadbias) | 0;\n\n                } catch (e) {}\n\n            }\n\n            if (k > lo) {\n\n                p = network[k--];\n\n                try {\n\n                    p[0] -= ((a * (p[0] - b)) / alpharadbias) | 0;\n                    p[1] -= ((a * (p[1] - g)) / alpharadbias) | 0;\n                    p[2] -= ((a * (p[2] - r)) / alpharadbias) | 0;\n\n                } catch (e) {}\n\n            }\n\n        }\n\n    }\n\n\n    // Move neuron i towards biased (b,g,r) by factor alpha\n    function altersingle(alpha, i, b, g, r) {\n\n        // alter hit neuron\n        var n = network[i];\n        var alphaMult = alpha / initalpha;\n        n[0] -= ((alphaMult * (n[0] - b))) | 0;\n        n[1] -= ((alphaMult * (n[1] - g))) | 0;\n        n[2] -= ((alphaMult * (n[2] - r))) | 0;\n\n    }\n\n    // Search for biased BGR values\n    function contest(b, g, r) {\n\n        // finds closest neuron (min dist) and updates freq\n        // finds best neuron (min dist-bias) and returns position\n        // for frequently chosen neurons, freq[i] is high and bias[i] is negative\n        // bias[i] = gamma*((1/netsize)-freq[i])\n\n        var i;\n        var dist;\n        var a;\n        var biasdist;\n        var betafreq;\n        var bestpos;\n        var bestbiaspos;\n        var bestd;\n        var bestbiasd;\n        var n;\n\n        bestd = ~(1 << 31);\n        bestbiasd = bestd;\n        bestpos = -1;\n        bestbiaspos = bestpos;\n\n        for (i = 0; i < netsize; i++) {\n\n            n = network[i];\n            dist = n[0] - b;\n\n            if (dist < 0) {\n                dist = -dist;\n            }\n\n            a = n[1] - g;\n\n            if (a < 0) {\n                a = -a;\n            }\n\n            dist += a;\n\n            a = n[2] - r;\n\n            if (a < 0) {\n                a = -a;\n            }\n\n            dist += a;\n\n            if (dist < bestd) {\n                bestd = dist;\n                bestpos = i;\n            }\n\n            biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n\n            if (biasdist < bestbiasd) {\n                bestbiasd = biasdist;\n                bestbiaspos = i;\n            }\n\n            betafreq = (freq[i] >> betashift);\n            freq[i] -= betafreq;\n            bias[i] += (betafreq << gammashift);\n\n        }\n\n        freq[bestpos] += beta;\n        bias[bestpos] -= betagamma;\n        return (bestbiaspos);\n\n    }\n\n    NeuQuantConstructor.apply(this, arguments);\n\n    var exports = {};\n    exports.map = map;\n    exports.process = process;\n\n    return exports;\n}\n\n},{}]},{},[2]);\n'],{type:"text/javascript"})));v.push(w),b.push(w)}var y=function(){for(var n=[],t=0;t<256;t++)n[t]=String.fromCharCode(t);return function(t){for(var e=t.length,i="",a=0;a<e;a++)i+=n[t[a]];return i}}();function C(n){h.length,c=n;for(var t=0;t<i&&t<h.length;t++)j(t)}function j(n){var t,i;if((t=h[n]).beingProcessed||t.done)return console.error("Frame already being processed or done!",t.position),void k();t.sampleInterval=e,t.beingProcessed=!0,(i=function(){if(0===b.length)throw"No workers left!";return b.pop()}()).onmessage=function(n){var e=n.data;delete t.data,t.pixels=Array.prototype.slice.call(e.pixels),t.palette=Array.prototype.slice.call(e.palette),t.transparencyIndex=e.transparencyIndex,t.done=!0,t.beingProcessed=!1,function(n){b.push(n)}(i),k()},i.postMessage(t)}function P(){for(var n=-1,t=0;t<h.length;t++){var e=h[t];if(!e.done&&!e.beingProcessed){n=t;break}}n>=0&&j(n)}function k(){var n=h.every(function(n){return!n.beingProcessed&&n.done});g(.75*++u/h.length),n?m||function(n,e){var i,l=[],d={loop:f};null!==s&&null!==o&&(i=o,d.palette=i);var h=new t(l,a,r,d);m=!0,n.forEach(function(t,e){var s;i||(s=t.palette),g(.75+.25*t.position*1/n.length),h.addFrame(0,0,a,r,t.pixels,{palette:s,delay:p,transparent:t.transparencyIndex})}),h.end(),g(1),n=[],m=!1,e(l)}(h,c):setTimeout(P,1)}function q(n){return 0!==n&&0==(n&n-1)}this.setSize=function(n,t){a=n,r=t,(l=document.createElement("canvas")).width=n,l.height=t,d=l.getContext("2d")},this.setDelay=function(n){p=.1*n},this.setRepeat=function(n){f=n},this.addFrame=function(n){null===d&&this.setSize(a,r),d.drawImage(n,0,0,a,r);var t=d.getImageData(0,0,a,r);this.addFrameImageData(t)},this.addFrameImageData=function(n){n.length;var t=new Uint8Array(n.data);h.push({data:t,width:n.width,height:n.height,palette:o,dithering:s,done:!1,beingProcessed:!1,position:h.length})},this.onRenderProgress=function(n){g=n},this.isRendering=function(){return m},this.getBase64GIF=function(n){C(function(t){var e=y(t),i="data:image/gif;base64,"+btoa(e);n(i)})},this.getBlobGIF=function(n){C(function(t){var e=new Uint8Array(t),i=new Blob([e],{type:"image/gif"});n(i)})},this.destroy=function(){v.forEach(function(n){n.terminate()})}}module.exports=Animated_GIF;

},{"omggif":1}]},{},[2])(2)
});
